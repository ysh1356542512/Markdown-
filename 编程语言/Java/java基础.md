# 数据类型

对于基本类型来说，==**栈**==区域包含的是基本类型的内容，也就是值；

例如 int a =2; 

对于引用类型来说，==**栈**==区域包含的是指向==**真正内容的指针**==（真正内容在堆中的地址），真正的

内容被分配在了==**堆**==中。

例如 Person dingshen=new Person();

## 基本数据类型

四类八种

### 数值型

#### 整数类型

##### byte

byte数据类型是8位，也就是一个字节



##### short

short 数据类型是 16 位、有符号的以二进制补码表示的整数（2个字节）

最小值是 **-32768****（****-2^15****）**；最大值是 **32767****（****2^15 - 1****）**

##### int

int 数据类型是32位、有符号的以二进制补码表示的整数；（4个字节）

最小值是 **-2,147,483,648****（****-2^31****）**；

最大值是 **2,147,483,647****（****2^31 - 1****）**； 

##### long

long 数据类型是 64 位、有符号的以二进制补码表示的整数；

最小值是 **-9,223,372,036,854,775,808****（****-2^63****）**；

最大值是 **9,223,372,036,854,775,807****（****2^63 -1****）**； 

#### 浮点类型

##### float

float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；

float 在储存大型浮点数组的时候可节省内存空间；

默认值是 **0.0f**； 

##### double

double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；

浮点数的默认类型为double类型；

#### 布尔型

##### boolean

boolean数据类型表示一位的信息；

只有两个取值：true 和 false；

这种类型只作为一种标志来记录 true/false 情况；

默认值是 **false**； 

##### char

char类型是一个单一的 16 位 Unicode 字符；

## 引用数据类型

### 类

（1）new关键字：表示向内存申请空间，也表示实例化一个对象，创建一个对象。
（2）一个对象在内存中的大小，由该对象的所有属性所占的内存大小的总和。引用类型变量在32位系统上占4个字节，在64位系统上占8个字节。加上而外的对象隐性数据所占的大小。
（3）相同的类型才可以赋值
（4）不同的引用，指向同一个对象，任何一个引用改变对象的值，其它引用都会反映出来。
（5）编程时要注意的问题，在确定不使用对象时，要尽早释放对象：引用=null
（6）==当一个堆中的对象没有被任何引用变量所指向时，该对象会被JVM 的 GC 程序认为是垃圾对象，从而被回收==



### 接口

### 数组

# 变量

类变量：独立于方法之外的变量，用 static 修饰。

实例变量：独立于方法之外的变量，不过没有 static 修饰。

局部变量：类的方法中的变量

==成员变量==和==局部变量==的区别
a、在类中的位置不同
	成员变量：在类中定义
	局部变量：在方法中定义或者方法的参数
b、在==内存==中的位置不同
	成员变量：==在堆内存(成员变量属于对象，对象进堆内存)==
	局部变量：==在栈内存(局部变量属于方法，方法进栈内存)==
c、生命周期不同
	成员变量：随着对象的创建而存在，随着对象的销毁而消失
	局部变量：==随着方法的调用而存在，随着方法的调用完毕而消==失
d、初始化值不同
	成员变量：有默认初始化值，引用类型默认为null
	局部变量：==没有默认初始化值，必须定义，赋值，然后才能使用==
注意：
	局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是==就近原则==。



## 实例变量

实例变量声明在一个类中，但在方法、构造方法和语句块之外；

当一个对象被实例化之后，每个实例变量的值就跟着确定；

实例变量在对象创建的时候创建，在对象被销毁的时候销毁

## 类变量

类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。

静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。

静态变量在第一次被访问时创建，在程序结束时销毁

## 局部变量

**局部变量在方法、构造方法、或者语句块被执行的时候创建**，当它们执行完成后，变量将会被销毁。**局**

**部变量没有默认值**，所以局部变量被声明后，**必须经过初始化**，才可以使用

# *Java*修饰符

Java中，可以使用Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。来保

护对类、变量、方法和构造方法的访问。

**default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接

口、变量、方法。

**private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**

**public** : 对所有类可见。使用对象：类、接口、变量、方法

**protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类**

**（外部类）**。  

# **封装性**

封装性的概念
封装性是面向对象思想的三大特征之一，封装就是隐藏实现细节，仅对外提供访问接口。实现细节部份包装、隐藏起来的方法。
封装有：属性的封装、方法的封装、类的封装、组件的封装、模块化封装、系统级封装…
封装的好处：模块化、信息隐藏、代码重用、插件化易于调试、具有安全性
封装的缺点：会影响执行效率

# **this关键字**

this关键字指向的是当前对象的引用
调用类中的属性：this.属性名称，指的是访问类中的成员变量，用来区分成员变量和局部变量（重名问题）
调用类中的方法：this.方法名称，用来访问本类的成员方法
调用类构造方法：this();访问本类的构造方法，()中可以有参数的 如果有参数 就是调用指定的有参构造
==注意：==
1.this() 不能使用在普通方法中，只能写在构造方法中
2.必须是构造方法中的第一条语句

# **值传递与引用传递**

**首先，注意：在java中只有按值传递，并没有所谓的按引用传递**
java数据类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）![img](https://img2018.cnblogs.com/blog/1271254/201907/1271254-20190701153202775-2050721336.png)

main函数调用swap函数来交换 x，y的值，然而调用函数之后发现main中x，y的值并未交换。包括在Java api中找不到一个可以交换两个变量的方法。这与Java语言的特性有关。通过一个图就可以知道上面程序的运行结果了。![img](https://img2018.cnblogs.com/blog/1271254/201907/1271254-20190701153455043-1779820622.png)

main函数中的x，y和swap函数中的x，y==分别存放在不同的区域==，在main中调用swap函数的时候，会将main中的x，y的值赋给swap中的x，y。当swap函数中对x，y交换时只是对swap==帧==中的x，y做交换，并不会改变main中的x，y。所以当函数返回时main中的x，y并不会改变

# **static**

static关键字的作用：方便在没有创建对象的情况下来进行调用（方法/变量）。
a、使用static关键字修饰一个属性：声明为static的变量实质上就是全局变量
b、使用static关键字修饰一个方法：在一个类中定义一个方法为static，那就是说，无需本类的对象即可调用此方法（类调用）
c、使用static关键字修饰一个类（==内部类==）：
声明为static的方法有以下几条限制： 
它们仅能调用其他的static 方法，反过来是可以的。 
它们只能访问static数据。 
==它们不能以任何方式引用this或super。==
==不允许用来修饰局部变量==

# **main**方法分析

主方法：
public static void main(String[] args){
    　　//代码块
}

public：公有的，最大的访问权限
static：静态的，无需创建对象
void:：表示没有返回值，无需向JVM返回结果
main：方法名，固定的方法名
String[] args：表示参数为字符串数组，可以在调用方法时传入参数

 

# **继承**

继承是面向对象三大特征之一
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类

被继承的类称为父类（超类），继承父类的类称为子类（派生类）
通过继承可以实现代码重用
子类拥有==父类非 private 的属性、方法==。
子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
子类可以用==自己的方式实现父类的方法。==
==构造器而言，它只能够被调用，而不能被继承，可以通过使用super()进行调用，==
对于继承而已，子类会==默认==调用==父类==的==构造器==，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器（通过super（）），而且必须是在子类构造器中做的第一件事(第一行代码)。
对于==protected==而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是==可以访问==的
Java 的继承是单继承，但是可以多重继承，

protected（受保护的访问权限修饰符，用于修饰属性和方法，使用protected修饰的属性和方法可以被子类继承）


（1）继承是发生在多个类之间
（2）继承使用关键字extends
（3）JAVA只能单继承，允许多层继承
（4）被继承的类叫父类（超类），继承父类的类叫子类（派生类）
（5）在父类中的非私有属性和方法可以被子类继承
（6）protected（受保护的访问权限修饰符），修饰的属性或方法可以被子类继承
（7）构造方法不能被继承
（8）创建对象会调用构造方法，调用构造方法不一定就是创建对象
（9）实例化子类对象，会先调用父类的构造方法，如果父类中没有默认的构造方法，那么子类必须显示的通过super(...)来调用父类的带参构造方法，super也只能在子类构造方法中的第一句

继承的好处：
a、提高代码的复用性
b、提高代码的维护性
c、让类与类之间产生关系，是多态的前提
继承的缺点：增强了类与类之间的耦合性

# **对象初始化**

```java
public class CodeBlockTest {
　　public static void main(String[] args) {
　　Child child = new Child();
}
}
class Father {
　　public static String fatherStr1 = "fatherStr1（静态字段初始化值）";

　　public String fatherStr2 = "fatherStr2（字段初始化值）";
　　static {
　　　　System.out.println("父类静态代码块：" + fatherStr1);
　　　　fatherStr1 = "fatherStr1（静态代码块赋值）";
　　}
　　{
　　　　System.out.println("父类构造代码块：" + fatherStr2);
　　　　fatherStr2 = "fatherStr2（构造代码块赋值）";
　　}
　　public Father() {
　　System.out.println("父类构造函数块：" + fatherStr2);
　　fatherStr2 = "fatherStr2（构造函数赋值）";
　　}
}


class Child extends Father {
　　public static String childStr1 = "childStr1（静态字段初始化值）";
　　public String childStr2 = "childStr2（字段初始化值）";
　　static {
　　　　System.out.println("子类静态代码块：" + childStr1);
　　　　childStr1 = "childStr1（静态代码块赋值）";
　　}
　　{
　　　　System.out.println("子类构造代码块：" + childStr2);
　　　　childStr2 = "childStr2（构造代码块赋值）";
　　}
　　public Child() {
　　System.out.println("子类构造函数：" + childStr2);
　　childStr2 = "childStr2（构造函数赋值）";
　　}
}
// 输出结果：
// 父类静态代码块：fatherStr1（静态字段初始化值）
// 子类静态代码块：childStr1（静态字段初始化值）
// 父类构造代码块：fatherStr2（字段初始化值）
// 父类构造函数块：fatherStr2（构造代码块赋值）
// 子类构造代码块：childStr2（字段初始化值）
// 子类构造函数：childStr2（构造代码块赋值）
```

通过每执行一个代码块或构造函数，输出字段在上一代码块执行后的值，以此来探究对象的初始化顺序。
由目前的输出结果可知，对于对象的初始化顺序，我们可以得出以下结论：
==\1.父类静态字段初始化
\2. 父类静态代码块、子类静态字段初始化 （接下来探究两者的顺序）
\3. 子类静态代码块
\4. 父类普通字段初始化
\5. 父类构造代码块
\6. 父类构造函数
\7. 子类普通字段初始化
\8. 子类构造代码块
\9. 子类构造函数==

```java
public class CodeBloacTest2 {
　　public static void main(String[] args) {
　　Child child = new Child();
}
}
class Father {
　　public static String fatherStr = "（静态字段初始化值）";
　　static {
　　　　System.out.println("父类静态代码块：fatherStr" + fatherStr);
　　　　fatherStr = "（静态代码块赋值）";
　　}
}


class Child extends Father {
　　public static String childStr = fatherStr;
　　static {
　　　　System.out.println("子类静态代码块：childStr = fatherStr" + childStr);
　　　　childStr = "（静态代码块赋值）";
　　}
}
// 输出结果：
// 父类静态代码块：fatherStr（静态字段初始化值）
// 子类静态代码块：childStr = fatherStr（静态代码块赋值
```

我们在子类静态字段childStr初始化的时候，赋的是父类静态字段fatherStr的值。由输出结果可知，childStr初始化后的值是父类静态代码块执行后赋予fatherStr的值。由此可知两者的执行顺序为：父类静态代码块==>子类静态字段初始化

初始化顺序（最终结果）：

==父类静态字段初始化
父类静态代码块
子类静态字段初始化
子类静态代码块
父类普通字段初始化
父类构造代码块
父类构造函数
子类普通字段初始化
子类构造代码块
子类构造函数==

# **方法的重写**

方法重写(overriding method)
在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。
在子类和父类中，重写方法后，在调用时，以创建的对象类型为准，会调用谁的方法。


重写特性：
a、发生在子父类中，方法重写的两个方法返回值、方法名、参数列表必须完全一致（子类重写父类的方法）
b、==子类抛出的异常不能超过父类相应方法抛出的异常（子类异常不能大于父类异常）==
c、==子类方法的访问级别不能低于父类相应方法的访问级别==(子类访问级别不能低于父类访问级别)
d、==父类中的方法若使用private、static、final任意修饰符修饰，那么，不能被子类重写。==

面试题 ：overloading与overriding的区别？(重载 重写)

# **super关键字**

可以理解为对==父类的引用==，使用super来调用父类的属性，方法，和构造方法
super可以完成以下的操作：
a、使用super调用父类中的属性，可以从父类实例处获得信息。
b、使用super调用父类中的方法，可以==委托==父类对象帮助完成某件事情。
c、使用super调用父类中的构造方法（super(实参)形式），必须在子类构造方法的==第一条语句==，调用父类中相应的构造方法，若不显示的写出来，默认调用父类的无参构造方法，比如：super();

# **final关键字**

使用final关键字完成以下的操作：
a、使用final关键字声明一个常量
	当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果==final修饰一个引用类型==时，则在对其初始化之后便==不能再让其指向其他对象==了，但该引用所指向的对象的内容是==可以发生变化==的
b、使用final关键字声明一个方法
	==该方法为最终方法，且只能被子类继承，但是不能被子类重写。==
c、使用final关键字声明一个类
	该类就转变为最终类，没有子类的类，==fianl修饰的类无法被继承。==
d、在方法参数中使用final，==在该方法内部不能修改参数的值==（在内部类中详解）

当final变量是基本数据类型以及String类型时，如果在==编译期==间能知道它的确切值，则编译器会把它当做编译期常量使用，不过要注意，==只有==在编译期间能确切知道==final变量值==的情况下，编译器才会进行这样的==优化==
引用变量被final修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。

# **抽象类**

抽象类的基本概念
（1）很多具有相同特征和行为的对象可以抽象为一个类；很多具有相同特征和行为的类可以抽象为一个抽象类。
（2）使用abstract关键字声明的类为抽象类

定义一个抽象类

abstract class Animal{
    　　public abstract void move();
}
abstract class Person extends Animal{
    　　private String name;
    　　//...
    　　public abstract void eat();//抽象方法
}

抽象类的规则：
a、抽象类可以没有抽象方法，==有抽象方法的类必须是抽象类==
b、非抽象类继承抽象类必须==实现==所有抽象方法
c、抽象类可以继承抽象类，可以==不实现==父类抽象方法。
d、抽象类可以有==方法实现和属性==
e、抽象类不能被==实例化==
f、==抽象类不能声明为final==
g、==抽象类可以有构造方法==

# **接口**

接口的定义格式：
interface 接口名称{
	　　全局常量 ;
	　　抽象方法 ;
}
示列：
interface IEat{
   　　//public abstract void eat();
    　　void eat(); //默认为public abstract void eat();
  　　//public static final int NUM = 10;
    　　int NUM = 10; }

interface ISleep extends IEat{
    void sleep();
}
接口的使用规则：
（1）定义一个接口，使用interface关键字
（2）在一个接口中，只能定义常量、抽象方法，JDK1.8后可以定义默认的实现方法
（3）接口可以继承多个接口：extends xxx,xxx
（4）一个具体类实现接口使用implements关键字
（5）一个类可以实现多个接口
（6）==抽象类实现接口可以不实现接口的方法==
（7）在接口中定义的方法没有声明 访问修饰符，默认为public
（8）==接口不能有构造方法==
（9）==接口不能被实例化==
java8新增
（1）增加了default方法和static方法,这两种方法完全可以有方法体
（2）default方法属于实例,static方法属于类(接口)
（3）==接口中的静态方法不会被继承,接口中的静态变量会被继承==

public interface IUser {
    　　static void say() {
        　　System.out.println("say_" + IUser.class);
    　}

​    　　default void eat() {
​        　　System.out.println("eat_" + IUser.class);
​    　}
}

# **多态性**

多态就是指程序中定义的==引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定==，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性

==多态性我们大概可以分为两类：==
（1）方法的重载与重写
（2）对象的多态性

//用父类的引用指向子类对象（用大的类型去接受小的类型，向上转型、自动转换）
Chicken home = new HomeChicken();

在编程时针对抽象类型的编写代码，称为面向抽象编程（或面向接口编程）父类通常都定义为抽象类、接口

对象的多态性：
对象多态性是从继承关系中的多个类而来，
向上转型：==将子类实例转为父类引用==
格式：父类 父类对象 = 子类实例 ； 自动转换
以基本数据类型操作为例：int i = ‘a' ; 
（因为char的容量比int小，所以可以自动完成）

==向下转型==：将父类实例转为子类实例 
格式：子类 子类对象 = （子类）父类实例 ；强制转换
以基本数据类型操作为例：char c = (char)97; 
 ==因为整型是4个字节比char 2个字节要大，所以需要强制完成==

a、方法的重载与重写就是方法的多态性表现
b、多个子类就是父类中的多种形态
c、父类引用可以指向子类对象，自动转换
d、==子类对象指向父类引用需要强制转换（注意：类型不对会报异常）==
e、在实际开发中尽量使用父类引用（更利于扩展）


==指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性==，而对于子类中存在而父类中不存在的方法，
该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，
必定是使用子类中定义的这些方法（动态连接、动态调用）。
例如：
class A{
	　　void fun1(){}
	　　void fun2(){}
}

class B extends A{
	　　void fun1(String a){}  //重载fun1
	　　void fun2(){}		//重写fun2
}

class C{
	　　public static void main(String[] args){
		　　A a = new B();
		　　a.fun1(); //这里会调用A类的fun1方法，由于向上转型，B的fun1(String a) 会被丢弃
		　　a.fun2(); //这里调用B的fun2方法，由于是new 的B对象，而B重写了fun2，所以会调用B的fun2
	}
}

对于面向对象而言，==多态==分为==编译时==多态和==运行时==多态。其中编辑时多态是静态的，主要是指方法的重载，而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性

java实现多态有三个必要条件：==继承、重写、向上转型==。
继承：在多态中必须存在有继承关系的子类和父类。
重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法

基于继承实现的多态
继承是通过重写父类的同一方法的几个不同子类来体现的
对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，
执行相同动作产生的行为也就不同。

基于接口实现的多态
指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。

# **instanceof关键字**

instanceof 是用于检查对象是否为指定的类型，通常在把父类引用强制转换为子类引用时要使用，以避免发生类型转换异常（ClassCastException）。

语法格式如下：
对象 instanceof 类型－－返回boolean类型值

示例：
if(homeChicken instanceof Chicken){
	　　//...
}
该语句一般用于判断一个对象是否为某个类的实例，是返回true，否返回false
父类的设计法则
通过instanceof关键字，我们可以很方便的检查对象的类型，但如果一个父类的子类过多，这样的判断还是显得很繁琐，那么如何去设计一个父类呢？
a、父类通常情况下都设计为抽象类或接口，其中优先考虑接口，如接口不能满足才考虑抽象类。

*b、一个具体的类尽可能不去继承另一个具体类，这样的好处是无需检查对象是否为父类的对象。*

# **内部类**

内部类就是在一个类的内部定义的类。
成员内部类：==内部类对象依赖外部类对象而存在==，即在创建一个普通内部类对象时首先需要创建其外部类对象
==内部类对象可以访问外部类对象中所有访问权限的字段==，同时，外部类对象也可以通过内部类的对象引用来访问内部类中定义的所有访问权限的字段
成员内部类格式如下：
class Outer {
      　　class Inner{}
}
编译上述代码会产生两个文件：
Outer.class和Outer$Inner.class。

在外部创建内部类对象
内部类除了可以在外部类中产生实例化对象，也可以在外部类的外部来实例化。
那么，根据内部类生成的*.class文件：Outer*I**n**n**e**r*.*c**l**a**s**s*“

” 符号在程序运行时将替换成“.”
所以内部类的访问：通过“外部类.内部类”的形式表示。

Outer out = new Outer() ;// 产生外部类实例
Outer.Inner in = null; // 声明内部类对象
in = out.new Inner() ; // 实例化内部类对象

## ==局部内部类==
内部类可以作为一个类的成员外，还可以把类放在方法内定义（不常用，匿名内部类可以显示局部内部类的功能）。
在==局部内部类里面可以访问外部类对象的所有访问权限的字段，而外部类却不能访问局部内部类中定义的字段==
注意：
a==、局部内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化==。
b、==局部内部类对象不能使用该内部类所在方法的非final局部变量。==
class Outer {
   　　public void doSomething(){
       　　class Inner{
            　　　　public void seeOuter(){}
       　　}
   　　}
}

## ==静态内部类==

在一个类内部定义一个静态内部类：
==静态的含义是该内部类可以像其他静态成员一样，没有外部类对象时，也能够访问它==。==静态嵌套类仅能访问外部类的静态成员和方法==。
静态内部类中也无法==访问==外部类的==非静态成员==
class Outer{
    　　static class Inner{}
}
class Test {
     　　public static void main(String[] args){
          　　Outer.Inner n = new Outer.Inner();
     }
}

## ==匿名内部类==
匿名内部类就是没有名字的内部类。
匿名内部类的三种情况：
（1）==继承==式的匿名内部类
（2）==接口==式的匿名内部类
（3）==参数式==的匿名内部类

在使用匿名内部类时，要记住以下几个原则：
（1）不能有构造方法，只能有一个实例。
（2）不能定义任何静态成员、静态方法。
（3）不能是public,protected,private,static。
（4）一定是在new的后面，用其隐含实现一个接口或继承一个类。
（5）匿名内部类为局部的，所以局部内部类的所有限制都对其生效

==局部内部类访问局部变量必须用final修饰，为什么?==
当调用这个方法时，局部变量如果没有用final修饰，他的生命周期和方法的生命周期是一样的，当方法被调用时会入栈，
方法结束后即==弹栈==，这个局部变量也会==消失==，那么如果局部内部类对象还没有马上消失想用这个局部变量，==显然已无法使用了==，
如果用==final修饰==会在类加载的时候进入==常量池==，==即使==方法弹栈，==常量池==的常量还在，也就可以==继续使用==了。

注意：在jdk1.8中取消了在局部内部类中使用的变量必须显示的使用final修饰，==编译器默认会为这个变量加上final==

  ## ==内部类的作用==
每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，
内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。

依赖外部类对象的：成员内部类，方法内部类，匿名内部类
==静态内部类不依赖外部类的对象==。所以，我们在项目中优先考虑选择静态内部类（不会产生==内存泄露==）
