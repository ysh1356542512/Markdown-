常用的第三方库



## ==EventBus==

### 背景

常见的通信方式：广播（耗时（一般都是需要去拿到上下文的时候）），接口回调，binder，intent（对象序列化，传递的大小有限制，底层用的binder机制），handler（内存泄漏）

### 优点

1. 使用起来很简单
2. 实现解耦
3. jar包轻量
4. 稳定
5. 速度快
6. 线程切换方便

### 三个角色

1. Event： 它可以是任意类型，EventBus会根据事件类型进行全局的通知。
2. **Subscriber**：事件订阅者，在EventBus 3.0之前我们必须定义以onEvent开头的那几个方法，分别是`onEvent`、`onEventMainThread`、`onEventBackgroundThread`和`onEventAsync`，而在3.0之后事件处理的方法名可以随意取，不过需要加上注解`@subscribe`，并且指定线程模型，默认是`POSTING`。
3. **Publisher**：事件的发布者，可以在任意线程里发布事件。一般情况下，使用`EventBus.getDefault()`就可以得到一个EventBus对象，然后再调用`post(Object)`方法即可。

### 四种线程模型

1. **POSTING**：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。
2. **MAIN**：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。
3. **BACKGROUND**：表示事件处理函数的线程在后台线程，因此不能进行UI操作。如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。
4. **ASYNC**：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。

### 使用

####     	定义事件

首先要定义一个事件封装为对象，在程序的内部使用该对象作为通信的信息

```java
public class MessageWrap {

    public final String message;

    public static MessageWrap getInstance(String message) {
        return new MessageWrap(message);
    }

    private MessageWrap(String message) {
        this.message = message;
    }
}
```



####     		发布事件

```java
EventBus.getDefault().post(MessageWrap.getInstance(msg));
```



#### 接受事件



```java
@Subscribe(threadMode = ThreadMode.MAIN)
    public void onGetMessage(MessageWrap message) {
        getBinding().tvMessage.setText(message.message);
    }
```

### 	黏性事件

所谓的黏性事件就是指发送了该事件之后再来订阅的订阅者依然能够接收到的事件

### 使用

订阅者的不同

```java
//在注解的后面 再设置一个反射的值
@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)

```

发送者的方法不同

```java
 EventBus.getDefault().postSticky(MessageWrap.getInstance(msg));
```

### ==实现原理思想==

它的本质就是利用注册来保存订阅者的信息（这里通常包括已经添加注解的方法信息，且注解里面的线程信息，和单一的返回值类型），将他们保存在一个集合里面，把事件的类设计为单利模式，在需要发送事件的地方直接发送事件，然后并且刚才已经获得了注册类的信息也就是接受者 直接遍历 事件类里面的接收者集合，找到相同的参数信息，并且选择用反射来调用相应的方法就这样完成了 各个板块之间的通信。

### 性能调优==ATP==

主要就是把注册的地方换成注解处理器，不去使用反射来提升性能（使用注解处理器来生成模板代码，来提升性能）

### 优先级

在`Subscribe`注解中总共有3个参数  而第三个就是优先级参数

#### 注意

只有当两个订阅方法使用相同的`ThreadMode`参数的时候，它们的优先级才会与`priority`指定的值一致；

只有当某个订阅方法的`ThreadMode`参数为`POSTING`的时候，它才能停止该事件的继续分发。

```java
// 订阅方法，需要与上面的方法的threadMode一致，并且优先级略高
@Subscribe(threadMode = ThreadMode.POSTING, sticky = true, priority = 1)
public void onGetStickyEvent(MessageWrap message) {
    String txt = "Sticky event: " + message.message;
    getBinding().tvStickyMessage.setText(txt);
    if (stopDelivery) {
        // 终止事件的继续分发
        EventBus.getDefault().cancelEventDelivery(message);
    }
```

## ==Rxjava==

### 概述

Rxjava的链式调用可以保证逻辑的清晰

### 成员



![](https://upload-images.jianshu.io/upload_images/944365-4c1c1eb44ffe01e5.png)

![](https://upload-images.jianshu.io/upload_images/944365-331c1c459d00d986.png)



### 创建操作符

#### 用途

主要用来创建Observable（被观察者）

#### creat

 使用OnSubscribe从头创建一个Observable，这种方法比较简单。

```java
    Observable.create(new Observable.OnSubscribe<String>() {

        @Override
        public void call(Subscriber<? super String> subscriber) {

            subscriber.onNext("item1");
            subscriber.onNext("item2");
            subscriber.onCompleted();
        }
    });
```

#### from

##### fromArray

这里的每一个数据元素都会作为一个事件源产生

```java
Observable.fromArray("1", "AAAA", "2", "1", "AAAA", "2", "1", "AAAA", "2", "1", "AAAA", "2", "1", "AAAA", "2")
        .subscribe(observer);
```

##### fromCallable

```java
Observable.fromCallable(new Callable<Object>() {
    @Override
    public Object call() throws Exception {
        return "aaa";
    }
}).subscribe(observer);
```

##### fromFuture

```java
ArrayList<String> list = new ArrayList<>();
list.add("111");
list.add("222");
Observable.fromIterable(list)
        .subscribe(observer);

Observable.fromFuture(new Future<Object>() {
    @Override
    public boolean cancel(boolean mayInterruptIfRunning) {
        return false;
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Override
    public boolean isDone() {
        return false;
    }

    @Override
    public Object get() throws ExecutionException, InterruptedException {
        return "aaaa";
    }

    @Override
    public Object get(long timeout, TimeUnit unit) throws ExecutionException, InterruptedException, TimeoutException {
        return null;
    }
}).subscribe(observer);
```

##### formiterable

```java
//        ArrayList<String> list = new ArrayList<>();
//        list.add("111");
//        list.add("222");
//        Observable.fromIterable(list)
//                .subscribe(observer);
```



 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为`OnSubscribe`是通过`OnSubscribeToObservableFuture`进行的，Iterable转换通过`OnSubscribeFromIterable`进行。数组通过`OnSubscribeFromArray`转

#### just

 多个事件源，将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是`ScalarSynchronousObservable`对象。如果是多个对象，则是调用了from方法创建。

####  empty

创建一个什么都不做直接通知完成的Observable

#### **error**

： 创建一个什么都不做直接通知错误的Observable

#### **never**

创建一个什么都不做的Observable

```java
    Observable observable1=Observable.empty();//直接调用onCompleted。
    Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常
    Observable observable3=Observable.never();//啥都不做
```



#### **timer**

 创建一个在给定的延时之后发射数据项为0的`Observable<Long>`,内部通过`OnSubscribeTimerOnce`工作

```java
 Observable.timer(1000,TimeUnit.MILLISECONDS)
            .subscribe(new Action1<Long>() {
                @Override
                public void call(Long aLong) {
                    Log.d("JG",aLong.toString()); // 0
                }
            });
```

#### **interval**

  创建一个按照给定的时间间隔发射从0开始的整数序列的`Observable<Long>`，内部通过`OnSubscribeTimerPeriodically`工作。

```java
  Observable.interval(1, TimeUnit.SECONDS)
            .subscribe(new Action1<Long>() {
                @Override
                public void call(Long aLong) {
                     //每隔1秒发送数据项，从0开始计数
                     //0,1,2,3....
                }
            });
```

#### **range**

  创建一个发射指定范围的整数序列的`Observable<Integer>`

```java
 Observable.range(2,5).subscribe(new Action1<Integer>() {
        @Override
        public void call(Integer integer) {
            Log.d("JG",integer.toString());// 2,3,4,5,6 从2开始发射5个数据
        }
    });
```

#### **defer**

只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过`OnSubscribeDefer`在订阅时调用Func0创建Observable。

```java
  Observable.defer(new Func0<Observable<String>>() {
        @Override
        public Observable<String> call() {
            return Observable.just("hello");
        }
    }).subscribe(new Action1<String>() {
        @Override
        public void call(String s) {
            Log.d("JG",s);
        }
    });
```



### 变换操作符



#### **cast**

在发射之前强制将Observable发射的所有数据转换为指定类型









#### map

```java
// map: 对被观察者进行处理，把原来发射出来的事件进行处理并且产生新的事件，再次创建新的被观察者，发射事件
Observable.just("aaa")
        .map(new Function<String, Object>() {
            @Override
            public Object apply(@NonNull String s) throws Exception {
                return "BBBB";
            }
        }).subscribe(observer);
```

#### flatmap

 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。

//示例一

```java
       Observable.just(2,3,5)
            .flatMap(new Func1<Integer, Observable<String>>() {
                @Override
                public Observable<String> call(Integer integer) {
                    return Observable.create(subscriber -> {
                        subscriber.onNext(integer*10+"");
                        subscriber.onNext(integer*100+"");
                        subscriber.onCompleted();
                    });
                }
            })
    .subscribe(o -> Log.d("JG",o)) //20,200,30,300,50,500
```





```java
Observable.just("111", "222", "333", "444", "55")
        .flatMap(new Function<String, ObservableSource<?>>() {
            @Override
            public ObservableSource<?> apply(@NonNull String s) throws Exception {
                return Observable.just(s + "ssss");
            }
        }).subscribe(observer);
```

```java
//诠释map操作符和flat操作符的区别   对于多个事件的处理
//map
Observable.fromIterable(StudentModel.getStudents())
        .map(new Function<Student, List<Student.Course>>() {
            @Override
            public List<Student.Course> apply(@NonNull Student student) throws Exception {
                return student.getCourseList();
            }
        }).subscribe(new Consumer<List<Student.Course>>() {
    @Override
    public void accept(List<Student.Course> courseList) throws Exception {
        for (Student.Course course : courseList) {
            System.out.println(course);
        }
    }
});
//flatmap
Observable.fromIterable(StudentModel.getStudents())
        .flatMap(new Function<Student, ObservableSource<?>>() {
            @Override
            public ObservableSource<?> apply(@NonNull Student student) throws Exception {
                return Observable.fromIterable(student.getCourseList());
            }
        }).subscribe(new Consumer<Object>() {
    @Override
    public void accept(Object o) throws Exception {
        System.out.println(o);
    }
});
```



#### concatmap

基本上和flatmap一样的，但是它是有序的而flatmap是无序的

类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。

#### buffer



它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个

```java
// 网络请求场景当中常用的操作符
Observable.just("111", "222", "333", "444", "55", "666", "777", "888", "999", "AAAAA")
        .buffer(3)
        .subscribe(observer);
```

#### **flatMapIterable**

 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。

```java
        Observable.just(2,3,5)
            .flatMapIterable(new Func1<Integer, Iterable<String>>() {
                @Override
                public Iterable<String> call(Integer integer) {
                    return Arrays.asList(integer*10+"",integer*100+"");
                }
            }).subscribe(new Action1<String>() {
              @Override
              public void call(String s) {
            
              }
    });
```



#### **switchMap**

 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。

```java
  Observable.create(new Observable.OnSubscribe<Integer>() {

        @Override
        public void call(Subscriber<? super Integer> subscriber) {
            for(int i=1;i<4;i++){
                subscriber.onNext(i);
                Utils.sleep(500,subscriber);//线程休眠500ms
            }

            subscriber.onCompleted();
        }
    }).subscribeOn(Schedulers.newThread())
      .switchMap(new Func1<Integer, Observable<Integer>>() {
             @Override
           public Observable<Integer> call(Integer integer) {
                   //每当接收到新的数据，之前的Observable将会被取消订阅
                    return Observable.create(new Observable.OnSubscribe<Integer>() {
                        @Override
                        public void call(Subscriber<? super Integer> subscriber) {
                            subscriber.onNext(integer*10);
                            Utils.sleep(500,subscriber);
                            subscriber.onNext(integer*100);
                            subscriber.onCompleted();
                        }
                    }).subscribeOn(Schedulers.newThread());
                }
            })
            .subscribe(s -> Log.d("JG",s.toString()));//10,20,30,300
```

#### **scan**

 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。

```java
  Observable.just(2,3,5)
            .scan(new Func2<Integer, Integer, Integer>() {
                @Override
                public Integer call(Integer sum, Integer item) {
                    return sum+item;
                }
            })
    .subscribe(integer -> Log.d("JG",integer.toString())) //2,5,10
```

#### **groupBy**

将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。

```java
   Observable.just(2,3,5,6)
            .groupBy(new Func1<Integer, String>() {
                @Override
                public String call(Integer integer) {//分组
                    return integer%2==0?"偶数":"奇数";
                }
            })
    .subscribe(new Action1<GroupedObservable<String, Integer>>() {
        @Override
        public void call(GroupedObservable<String, Integer> o) {

            o.subscribe(new Action1<Integer>() {
                @Override
                public void call(Integer integer) {
                    Log.d("JG",o.getKey()+":"+integer.toString()); //偶数：2，奇数：3，...
                }
            });
        }
    })
```

#### **window**

定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。

























### 组合操作符

##序连接多个Observables。需要注意的是`Observable.concat(a,b)`等价于`a.concatWith(b)`。

```java
    Observable<Integer> observable1=Observable.just(1,2,3,4);
    Observable<Integer>  observable2=Observable.just(4,5,6);

    Observable.concat(observable1,observable2)
            .subscribe(item->Log.d("JG",item.toString()));//1,2,3,4,4,5,6
```

#### **startWith**

 在数据序列的开头增加一项数据。`startWith`的内部也是调用了`concat`

```java
 Observable.just(1,2,3,4,5)
            .startWith(6,7,8)
    .subscribe(item->Log.d("JG",item.toString()));//6,7,8,1,2,3,4,5
```



#### **merge**

将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中`mergeDelayError`将异常延迟到其它没有错误的Observable发送完毕后才发射。而`merge`则是一遇到异常将停止发射数据，发送onError通知。



![](https://upload-images.jianshu.io/upload_images/1931185-57219b8f15ee8a93.png)



#### **zip**

使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过`OperatorZip`进行压.

```java
Observable<Integer>  observable1=Observable.just(1,2,3,4);
Observable<Integer>  observable2=Observable.just(4,5,6);
    Observable.zip(observable1, observable2, new Func2<Integer, Integer, String>() {
        @Override
        public String call(Integer item1, Integer item2) {
            return item1+"and"+item2;
        }
    })
    .subscribe(item->Log.d("JG",item)); //1and4,2and5,3and6
```

#### **combineLatest**

当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable==最近的数据==压合。具体请看下面流程图。

zip工作流程

![](https://upload-images.jianshu.io/upload_images/1931185-14134e499db9d0c4.png)

combineLatest工作流程

![](https://upload-images.jianshu.io/upload_images/1931185-1e60a8bf25b31e91.png)











































### 功能操作符



```java
subscribeOn observeOn
```

```java
subscribeOn(Schedulers.newThread())// 主要来决定我执行subscribe方法所处的线程，也就是产生事件发射事件所在的线程
        .observeOn(AndroidSchedulers.mainThread())// 来决定下游事件被处理时所处的线程
```





### 过滤操作符

#### filter

 过滤数据。内部通过`OnSubscribeFilter`过滤数据。

```java
  Observable.just(3,4,5,6)
            .filter(new Func1<Integer, Boolean>() {
                @Override
                public Boolean call(Integer integer) {
                    return integer>4;
                }
            })
    .subscribe(item->Log.d("JG",item.toString())); //5,6 

```



#### **ofType**

过滤指定类型的数据，与filter类似，

```java
Observable.just(1,2,"3")
            .ofType(Integer.class)
            .subscribe(item -> Log.d("JG",item.toString()));
```



#### **take**

只发射开始的N项数据或者一定时间内的数据。内部通过`OperatorTake`和`OperatorTakeTimed`过滤数据。

```java
  Observable.just(3,4,5,6)
            .take(3)//发射前三个数据项
            .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据
```

#### **takeLas**

只发射最后的N项数据或者一定时间内的数据。内部通过`OperatorTakeLast`和`OperatorTakeLastTimed`过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。

```java
 Observable.just(3,4,5,6)
            .takeLast(3)
            .subscribe(integer -> Log.d("JG",integer.toString()));//4,5,6
```

#### **takeFirst**

提取满足条件的第一项。内部实现源码如下：

```java
public final Observable<T> takeFirst(Func1<? super T, Boolean> predicate) {
      return filter(predicate).take(1); //先过滤，后提取
}
```

#### **first/firstOrDefault**

只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。

```java
 Observable.just(3,4,5,6)
            .first()
            .subscribe(integer -> Log.d("JG",integer.toString()));//3
            
    Observable.just(3,4,5,6)
               .first(new Func1<Integer, Boolean>() {
                   @Override
                   public Boolean call(Integer integer) {
                       return integer>3;
                   }
               }) .subscribe(integer -> Log.d("JG",integer.toString()));//4
```

#### **last/lastOrDefaul**

只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。

#### **skip**

跳过开始的N项数据或者一定时间内的数据。内部通过`OperatorSkip`和`OperatorSkipTimed`实现过滤。

```java
  Observable.just(3,4,5,6)
               .skip(1)
            .subscribe(integer -> Log.d("JG",integer.toString()));//4,5,6
```

**kipLast**

跳过最后的N项数据或者一定时间内的数据。内部通过`OperatorSkipLast`和`OperatorSkipLastTimed`实现过滤。

#### **elementAt/elementAtOrDefault**

发射某一项数据，如果超过了范围可以的指定默认值。内部通过`OperatorElementAt`过滤。

```java
        Observable.just(3,4,5,6)
                 .elementAt(2)
        .subscribe(item->Log.d("JG",item.toString())); //5
```

#### **ignoreElements**

丢弃所有数据，只发射错误或正常终止的通知。内部通过`OperatorIgnoreElements`实现

#### **distinct**

过滤重复数据，内部通过`OperatorDistinct`实现。

```java
 Observable.just(3,4,5,6,3,3,4,9)
       .distinct()
      .subscribe(item->Log.d("JG",item.toString())); //3,4,5,6,9
```

#### **distinctUntilChanged**

过滤掉连续重复的数据。内部通过`OperatorDistinctUntilChanged`实现

```java
 Observable.just(3,4,5,6,3,3,4,9)
       .distinctUntilChanged()
      .subscribe(item->Log.d("JG",item.toString())); //3,4,5,6,3,4,9
```

#### **throttleFirst**

定期发射Observable发射的第一项数据。内部通过`OperatorThrottleFirst`实现。

```java
Observable.create(subscriber -> {
        subscriber.onNext(1);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(2);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }

        subscriber.onNext(3);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(4);
        subscriber.onNext(5);
        subscriber.onCompleted();

    }).throttleFirst(999, TimeUnit.MILLISECONDS)
            .subscribe(item-> Log.d("JG",item.toString())); //结果为1,3,4
```



#### **throttleWithTimeout/debounce**

发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时
 才进行发射

```java
 Observable.create(subscriber -> {
         subscriber.onNext(1);
         try {
             Thread.sleep(500);
         } catch (InterruptedException e) {
             throw Exceptions.propagate(e);
         }
         subscriber.onNext(2);
         try {
             Thread.sleep(500);
         } catch (InterruptedException e) {
             throw Exceptions.propagate(e);
         }

         subscriber.onNext(3);
         try {
             Thread.sleep(1000);
         } catch (InterruptedException e) {
             throw Exceptions.propagate(e);
         }
         subscriber.onNext(4);
         subscriber.onNext(5);
         subscriber.onCompleted();

     }).debounce(999, TimeUnit.MILLISECONDS)//或者为throttleWithTimeout(1000, TimeUnit.MILLISECONDS)
             .subscribe(item-> Log.d("JG",item.toString())); //结果为3,5
```

#### **sample/throttleLast**

定期发射Observable最近的数据。内部通过`OperatorSampleWithTime`实现。

```java
 Observable.create(subscriber -> {
        subscriber.onNext(1);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(2);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }

        subscriber.onNext(3);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(4);
        subscriber.onNext(5);
        subscriber.onCompleted();

    }).sample(999, TimeUnit.MILLISECONDS)//或者为throttleLast(1000, TimeUnit.MILLISECONDS)
            .subscribe(item-> Log.d("JG",item.toString())); //结果为2,3,5
```



#### **timeout**

如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。

```java
   Observable.create(( subscriber) -> {
        subscriber.onNext(1);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(2);
       
        subscriber.onCompleted();

    }).timeout(999, TimeUnit.MILLISECONDS,Observable.just(99,100))//如果不指定备用Observable将会抛出异常
            .subscribe(item-> Log.d("JG",item.toString()),error->Log.d("JG","onError")); //结果为1,99,100  如果不指定备用Observable结果为1,onError
}
```





























































































































### 条件操作符

#### **all**

  判断所有的数据项是否满足某个条件，内部通过`OperatorAll`实现。

```java
  Observable.just(2,3,4,5)
            .all(new Func1<Integer, Boolean>() {
                @Override
                public Boolean call(Integer integer) {
                    return integer>3;
                }
            })
    .subscribe(new Action1<Boolean>() {
        @Override
        public void call(Boolean aBoolean) {
            Log.d("JG",aBoolean.toString()); //false
        }
    })
    ;
```

#### **exists**

  判断是否存在数据项满足某个条件。内部通过`OperatorAny`实现

```java
   Observable.just(2,3,4,5)
            .exists(integer -> integer>3)
            .subscribe(aBoolean -> Log.d("JG",aBoolean.toString())); //true
```

#### **contains**

 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是`exists`

```java
  Observable.just(2,3,4,5)
            .contains(3)
            .subscribe(aBoolean -> Log.d("JG",aBoolean.toString())); //true
```

#### **sequenceEqual**

用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。

```java
 Observable.sequenceEqual(Observable.just(2,3,4,5),Observable.just(2,3,4,5))
            .subscribe(aBoolean -> Log.d("JG",aBoolean.toString()));//true
```



#### **isEmpty**

  用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。

```java
  Observable.just(3,4,5,6)
               .isEmpty()
              .subscribe(item -> Log.d("JG",item.toString()));//false
```

#### **amb**

  给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他Observable将会被忽略。

```java
    Observable<Integer> observable1=Observable.create(new Observable.OnSubscribe<Integer>() {
        @Override
        public void call(Subscriber<? super Integer> subscriber) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                subscriber.onError(e);
            }
            subscriber.onNext(1);
            subscriber.onNext(2);
            subscriber.onCompleted();
        }
    }).subscribeOn(Schedulers.computation());

    Observable<Integer> observable2=Observable.create(subscriber -> {
        subscriber.onNext(3);
        subscriber.onNext(4);
        subscriber.onCompleted();
    });

    Observable.amb(observable1,observable2)
    .subscribe(integer -> Log.d("JG",integer.toString())); //3,4
```

####**switchIfEmpty**

  如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。

```java
   Observable.empty()
            .switchIfEmpty(Observable.just(2,3,4))
    .subscribe(o -> Log.d("JG",o.toString())); //2,3,4
```



#### **defaultIfEmpty**

如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。

#### **takeUntil**

当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据

```java
 Observable.just(2,3,4,5)
            .takeUntil(new Func1<Integer, Boolean>() {
                @Override
                public Boolean call(Integer integer) {
                    return integer==4;
                }
            }).subscribe(integer -> Log.d("JG",integer.toString())); //2,3,4
```

#### **takeWhile**

当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。

```java
  Observable.just(2,3,4,5)
            .takeWhile(new Func1<Integer, Boolean>() {
                @Override
                public Boolean call(Integer integer) {
                    return integer==4;
                }
            })
            .subscribe(integer -> Log.d("JG",integer.toString())); //2,3
```

#### **skipUntil**

丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）

#### **skipWhile**

丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）



### 聚合操作符



#### **reduce**

对序列使用reduce()函数并发射最终的结果,内部使用`OnSubscribeReduce`实现。

```java
  Observable.just(2,3,4,5)
            .reduce(new Func2<Integer, Integer, Integer>() {
                @Override
                public Integer call(Integer sum, Integer item) {
                    return sum+item;
                }
            })
            .subscribe(integer -> Log.d("JG",integer.toString()));//14
```





#### **collect**

使用`collect`收集数据到一个可变的数据结构。

```java
  Observable.just(3,4,5,6)
               .collect(new Func0<List<Integer>>() { //创建数据结构

                   @Override
                   public List<Integer> call() {
                       return new ArrayList<Integer>();
                   }
               }, new Action2<List<Integer>, Integer>() { //收集器
                   @Override
                   public void call(List<Integer> integers, Integer integer) {
                       integers.add(integer);
                   }
               })
              .subscribe(new Action1<List<Integer>>() {
                  @Override
                  public void call(List<Integer> integers) {
                      
                  }
              });
```



#### **count/countLong**

计算发射的数量，内部调用的是`reduce`.

### 转换操作

#### **toList**

收集原始Observable发射的所有数据到一个列表，然后返回这个列表.

```java
    Observable.just(2,3,4,5)
            .toList()
            .subscribe(new Action1<List<Integer>>() {
                @Override
                public void call(List<Integer> integers) {
                    
                }
            });
```

#### **toSortedList**

收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表

```java
   Observable.just(6,2,3,4,5)
            .toSortedList(new Func2<Integer, Integer, Integer>() {//自定义排序
                @Override
                public Integer call(Integer integer, Integer integer2) {
                    return integer-integer2; //>0 升序 ，<0 降序
                }
            })
            .subscribe(new Action1<List<Integer>>() {
                @Override
                public void call(List<Integer> integers) {
                    Log.d("JG",integers.toString()); // [2, 3, 4, 5, 6]
                }
            });
```

#### **toMap**

将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。

```java
    Observable.just(6,2,3,4,5)
            .toMap(new Func1<Integer, String>() {
                @Override
                public String call(Integer integer) {
                    return "key：" + integer; //根据数据项生成map的key
                }
            }, new Func1<Integer, String>() {
                @Override
                public String call(Integer integer) {
                    return "value："+integer; //根据数据项生成map的kvalue
                }
            }).subscribe(new Action1<Map<String, String>>() {
        @Override
        public void call(Map<String, String> stringStringMap) {
            Log.d("JG",stringStringMap.toString()); // {key：6=value：6, key：5=value：5, key：4=value：4, key：2=value：2, key：3=value：3}
        }
    });
```

#### **toMultiMap**

类似于toMap，不同的地方在于map的value是一个集合。



























### Rxjava内存泄漏

产生的原因就是  耗时操作（比如网络请求，数据库等 数据还没有回来）

而干掉activity的操作，但由于线程还没有结束，所以导致activity没有被回收所以导致内存泄漏。

#### 解决一

并不推荐使用  因为当请求很多的事件 就要写很多的Disposable垃圾代码

首先需要配置  目的是为了 捕获异常

```java
public class MyApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        // 取消订阅后，抛出的异常无法捕获，导致程序崩溃
        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
            @Override
            public void accept(Throwable throwable) throws Exception {
                Log.i("TAG", "setErrorHandler accept: throwable=" + throwable.toString());
            }
        });
    }
}
```

​	Rxjava的原码  subscribe 会返回一个Disposable类型

可以调用里面的disose方法  取消  可以解决

```java
@CheckReturnValue
@SchedulerSupport(SchedulerSupport.NONE)
public final Disposable subscribe(Consumer<? super T> onNext) {
    return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());
}
```

#### 解决二

利用感知生命周期来解决 内存泄漏的问题

先实现一个RxLifecycle

```java
public class RxLifecycle<T> implements LifecycleObserver, ObservableTransformer<T, T> {

    final CompositeDisposable compositeDisposable = new CompositeDisposable();

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    void onDestroy() {
        Log.i("TAG", "onDestroy: ");
        if (!compositeDisposable.isDisposed()) {
            compositeDisposable.dispose();
        }
    }

    @NonNull
    @Override
    public ObservableSource<T> apply(@NonNull Observable<T> upstream) {
        return upstream.doOnSubscribe(new Consumer<Disposable>() {
            @Override
            public void accept(Disposable disposable) throws Exception {
                compositeDisposable.add(disposable);
            }
        });
    }

    public static <T> com.dongnaoedu.rxjava.RxLifecycle<T> bindRxLifecycle(LifecycleOwner lifecycleOwner) {
        com.dongnaoedu.rxjava.RxLifecycle<T> lifecycle = new com.dongnaoedu.rxjava.RxLifecycle<>();
        lifecycleOwner.getLifecycle().addObserver(lifecycle);
        return lifecycle;
    }

}
```

第二步在环节当中使用这两个方法

```java
//这个是线程切换代码复用的封装
.compose(new com.dongnaoedu.rxjava.SchedulerTransformer<>())
    //解决内存泄漏问题的封装
.compose(com.dongnaoedu.rxjava.RxLifecycle.bindRxLifecycle(this))
```



==提优==

CompositeDisposable这个类 可以添加多个Disposable  一次性取消



#### compose

### 错误处理/重试机制

#### **onErrorResumeNext**

当原始Observable在遇到错误时，使用备用Observable。。

```java
  Observable.just(1,"2",3)
    .cast(Integer.class)
    .onErrorResumeNext(Observable.just(1,2,3))
    .subscribe(integer -> Log.d("JG",integer.toString())) //1,2,3
    ;
```

#### **onExceptionResumeNext**

当原始Observable在遇到异常时，使用备用的Observable。与`onErrorResumeNext`类似，区别在于`onErrorResumeNext`可以处理所有的错误，onExceptionResumeNext只能处理异常。

#### **onErrorReturn**

当原始Observable在遇到错误时发射一个特定的数据。

```java
 Observable.just(1,"2",3)
            .cast(Integer.class)
            .onErrorReturn(new Func1<Throwable, Integer>() {
                @Override
                public Integer call(Throwable throwable) {
                    return 4;
                }
            }).subscribe(new Action1<Integer>() {
        @Override
        public void call(Integer integer) {
            Log.d("JG",integer.toString());1,4
        }
    });
```

#### **retry**

当原始Observable在遇到错误时进行重试。

```java
    Observable.just(1,"2",3)
    .cast(Integer.class)
    .retry(3)
    .subscribe(integer -> Log.d("JG",integer.toString()),throwable -> Log.d("JG","onError"))
    ;//1,1,1,1,onError
```



#### **retryWhen**

当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是`retry`。

### 连接操作

`ConnectableObservable`与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。
 `ConnectableObservable.connect()`指示一个可连接的Observable开始发射数据.
 `Observable.publish()`将一个Observable转换为一个可连接的Observable
 `Observable.replay()`确保所有的订阅者看到相同的数据序列的`ConnectableObservable`，即使它们在Observable开始发射数据之后才订阅。
 `ConnectableObservable.refCount()`让一个可连接的Observable表现得像一个普通的Observable。

```java
       ConnectableObservable<Integer> co= Observable.just(1,2,3)
                .publish();

        co .subscribe(integer -> Log.d("JG",integer.toString()) );
        co.connect();//此时开始发射数据
```



### 阻塞操作

`BlockingObservable`是一个阻塞的Observable。普通的Observable 转换为 BlockingObservable，可以使用 `Observable.toBlocking( )`方法或者`BlockingObservable.from( )`方法。内部通过`CountDownLatch`实现了阻塞操作。。

以下的操作符可以用于BlockingObservable，如果是普通的Observable，务必使用Observable.toBlocking()转为阻塞Observable后使用，否则达不到预期的效果。

#### **forEach**

对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。

```java
Observable.just(2,3).observeOn(Schedulers.newThread()).toBlocking()
          .forEach(integer -> {
              Log.d("JG",integer.toString()+" "+Thread.currentThread().getName());
              Utils.sleep(500);
          });

Log.d("JG",Thread.currentThread().getName());
    // 2 RxNewThreadScheduler-1
    // 3 RxNewThreadScheduler-1
    // main
```



#### **first/firstOrDefault/last/lastOrDefault**：

这几个操作符之前有介绍过。也可以用于阻塞操作。

#### **single/singleOrDefault**：

如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。

**#### mostRecent**

：返回一个总是返回Observable最近发射的数据的Iterable。

**#### next**：

 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。

#### **latest**

 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值

**#### toFuture**

： 将Observable转换为一个Future

**#### toIterable**

：将一个发射数据序列的Observable转换为一个Iterable。

#### **getIterator**

：将一个发射数据序列的Observable转换为一个Iterator



### 工具集

#### **materialize**

将Observable转换成一个通知列表。

```java
 Observable.just(1,2,3)
           .materialize()
           .subscribe(new Action1<Notification<Integer>>() {
               @Override
               public void call(Notification<Integer> notification) {
                   Log.d("JG",notification.getKind()+" "+notification.getValue());
                   //OnNext 1
                   //OnNext 2
                   //OnNext 3
                   //OnCompleted null
               }
           });
```



#### **dematerialize**

与上面的作用相反，将通知逆转回一个Observable。

#### **timestamp**

给Observable发射的每个数据项添加一个时间戳。

```java
  Observable.just(1,2,3)
           .timestamp()
           .subscribe(new Action1<Timestamped<Integer>>() {
               @Override
               public void call(Timestamped<Integer> timestamped) {
                   Log.d("JG",timestamped.getTimestampMillis()+" "+timestamped.getValue());
                   //1472627510548 1
                   //1472627510549 2
                   //1472627510549 3
               }
           });
```

#### **timeInterval**

给Observable发射的两个数据项间添加一个时间差，实现在`OperatorTimeInterval`中

![](http://static.zybuluo.com/maplejaw/6dbl77xvh2z02hxil00juave/image_1argc8a1n17a61t441s5p1gln8231g.png)



#### **serialize**

： 强制Observable按次序发射数据并且要求功能是完好的

**#### cache**

： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者

#### **observeOn**

： 指定观察者观察Observable的调度器

**#### subscribeOn**

： 指定Observable执行任务的调度器

**#### doOnEach**

： 注册一个动作，对Observable发射的每个数据项使用

```java
   Observable.just(2,3)
             .doOnEach(new Action1<Notification<? super Integer>>() {
                 @Override
                 public void call(Notification<? super Integer> notification) {
                     Log.d("JG","--doOnEach--"+notification.toString());
                 }
             })
             .subscribe(integer -> Log.d("JG",integer.toString()));
 //结果为：            
  // --doOnEach--[rx.Notification@133c40b0 OnNext 2]
 // 2
  // --doOnEach--[rx.Notification@133c40b0 OnNext 3]
 // 3
// --doOnEach--[rx.Notification@df4db0e OnCompleted]
```

#### **doOnCompleted**

： 注册一个动作，对正常完成的Observable使用

**#### doOnError**

： 注册一个动作，对发生错误的Observable使用

**#### doOnTerminate**

：注册一个动作，对完成的Observable使用，无论是否发生错误

```java
  Observable.just(2,3)
            .doOnTerminate(new Action0() {
                @Override
                public void call() {
                    Log.d("JG","--doOnTerminate--");
                }
            })
            .subscribe(integer -> Log.d("JG",integer.toString()));
// 2 , 3 , --doOnTerminate--
```

#### **doOnSubscribe**

注册一个动作，在观察者订阅时使用。内部由`OperatorDoOnSubscribe`实现

![](http://static.zybuluo.com/maplejaw/9w3o5vxc0lzznbrpn4vwa78w/image_1argbe0o1atfqtbrj51gu0jho9.png)



**doOnUnsubscribe**： 注册一个动作，在观察者取消订阅时使用。内部由`OperatorDoOnUnsubscribe`实现，在`call`中加入一个解绑动作。

![](http://static.zybuluo.com/maplejaw/791vkq1lxpl2etqaql85a6e8/image_1argbhutoi1a1b6a18s9il6npvm.png)

#### **finallyDo/doAfterTerminate**

注册一个动作，在Observable完成时使用

```java
Observable.just(2,3)
            .doAfterTerminate(new Action0() {
                @Override
                public void call() {
                    Log.d("JG","--doAfterTerminate--");
                }
            })
            .subscribe(integer -> Log.d("JG",integer.toString()));
//2,3,  --doAfterTerminate-- 
```

#### **delay**

延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。



#### **delaySubscription**



延时处理订阅请求。实现在`OnSubscribeDelaySubscription`中

![](http://static.zybuluo.com/maplejaw/xqw7fto75revvct4zu3d56a5/image_1argc0tbetbj1rkj1etf4fcb1p13.png)



#### **using**

创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。

```java
  Observable.using(new Func0<File>() {//资源工厂
        @Override
        public File call() {

            File file = new File(getCacheDir(), "a.txt");
            if(!file.exists()){
                try {
                    Log.d("JG","--create--");
                    file.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return file;
        }
    }, new Func1<File, Observable<String>>() { //Observable
        @Override
        public Observable<String> call(File file) {
            return Observable.just(file.exists() ? "exist" : "no exist");
        }
    }, new Action1<File>() {//释放资源动作
        @Override
        public void call(File file) {
            if(file!=null&&file.exists()){
                Log.d("JG","--delete--");
                file.delete();
            }
        }
    })
    .subscribe(s -> Log.d("JG",s))
    ;
 //--create--
 //exist
 //--delete--
 
```

#### **single/singleOrDefault**

强制返回单个数据，否则抛出异常或默认数据



## ==Retrofit==

### 使用

```java
Retrofit retrofit = new Retrofit.Builder()
        .baseUrl("http://localhost:4567/")
        .build();
BlogService service = retrofit.create(BlogService.class);
Call<ResponseBody> call = service.getBlog(2);
// 用法和OkHttp的call如出一辙,
// 不同的是如果是Android系统回调方法执行在主线程
call.enqueue(new Callback<ResponseBody>() {
    @Override
    public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
        try {
            System.out.println(response.body().string());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onFailure(Call<ResponseBody> call, Throwable t) {
        t.printStackTrace();
    }
});


```

