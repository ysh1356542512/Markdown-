# 常用的第三方库



## ==EventBus==

### 背景

常见的通信方式：广播（耗时（一般都是需要去拿到上下文的时候）），接口回调，binder，intent（对象序列化，传递的大小有限制，底层用的binder机制），handler（内存泄漏）

### 优点

1. 使用起来很简单
2. 实现解耦
3. jar包轻量
4. 稳定
5. 速度快
6. 线程切换方便

### 三个角色

1. Event： 它可以是任意类型，EventBus会根据事件类型进行全局的通知。
2. **Subscriber**：事件订阅者，在EventBus 3.0之前我们必须定义以onEvent开头的那几个方法，分别是`onEvent`、`onEventMainThread`、`onEventBackgroundThread`和`onEventAsync`，而在3.0之后事件处理的方法名可以随意取，不过需要加上注解`@subscribe`，并且指定线程模型，默认是`POSTING`。
3. **Publisher**：事件的发布者，可以在任意线程里发布事件。一般情况下，使用`EventBus.getDefault()`就可以得到一个EventBus对象，然后再调用`post(Object)`方法即可。

### 四种线程模型

1. **POSTING**：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。
2. **MAIN**：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。
3. **BACKGROUND**：表示事件处理函数的线程在后台线程，因此不能进行UI操作。如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。
4. **ASYNC**：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。

### 使用

####     	定义事件

首先要定义一个事件封装为对象，在程序的内部使用该对象作为通信的信息

```java
public class MessageWrap {

    public final String message;

    public static MessageWrap getInstance(String message) {
        return new MessageWrap(message);
    }

    private MessageWrap(String message) {
        this.message = message;
    }
}
```



####     		发布事件

```java
EventBus.getDefault().post(MessageWrap.getInstance(msg));
```



#### 接受事件



```java
@Subscribe(threadMode = ThreadMode.MAIN)
    public void onGetMessage(MessageWrap message) {
        getBinding().tvMessage.setText(message.message);
    }
```

### 	黏性事件

所谓的黏性事件就是指发送了该事件之后再来订阅的订阅者依然能够接收到的事件

### 使用

订阅者的不同

```java
//在注解的后面 再设置一个反射的值
@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)

```

发送者的方法不同

```java
 EventBus.getDefault().postSticky(MessageWrap.getInstance(msg));
```

### ==实现原理思想==

它的本质就是利用注册来保存订阅者的信息（这里通常包括已经添加注解的方法信息，且注解里面的线程信息，和单一的返回值类型），将他们保存在一个集合里面，把事件的类设计为单利模式，在需要发送事件的地方直接发送事件，然后并且刚才已经获得了注册类的信息也就是接受者 直接遍历 事件类里面的接收者集合，找到相同的参数信息，并且选择用反射来调用相应的方法就这样完成了 各个板块之间的通信。

### 性能调优==ATP==

主要就是把注册的地方换成注解处理器，不去使用反射来提升性能（使用注解处理器来生成模板代码，来提升性能）

### 优先级

在`Subscribe`注解中总共有3个参数  而第三个就是优先级参数

#### 注意

只有当两个订阅方法使用相同的`ThreadMode`参数的时候，它们的优先级才会与`priority`指定的值一致；

只有当某个订阅方法的`ThreadMode`参数为`POSTING`的时候，它才能停止该事件的继续分发。

```java
// 订阅方法，需要与上面的方法的threadMode一致，并且优先级略高
@Subscribe(threadMode = ThreadMode.POSTING, sticky = true, priority = 1)
public void onGetStickyEvent(MessageWrap message) {
    String txt = "Sticky event: " + message.message;
    getBinding().tvStickyMessage.setText(txt);
    if (stopDelivery) {
        // 终止事件的继续分发
        EventBus.getDefault().cancelEventDelivery(message);
    }
```

## ==Rxjava==

### 概述

Rxjava的链式调用可以保证逻辑的清晰

### 成员



![](https://upload-images.jianshu.io/upload_images/944365-4c1c1eb44ffe01e5.png)

![](https://upload-images.jianshu.io/upload_images/944365-331c1c459d00d986.png)



### 创建操作符

#### 用途

主要用来创建Observable（被观察者）

#### creat

 使用OnSubscribe从头创建一个Observable，这种方法比较简单。

```java
    Observable.create(new Observable.OnSubscribe<String>() {

        @Override
        public void call(Subscriber<? super String> subscriber) {

            subscriber.onNext("item1");
            subscriber.onNext("item2");
            subscriber.onCompleted();
        }
    });
```

#### from

##### fromArray

这里的每一个数据元素都会作为一个事件源产生

```java
Observable.fromArray("1", "AAAA", "2", "1", "AAAA", "2", "1", "AAAA", "2", "1", "AAAA", "2", "1", "AAAA", "2")
        .subscribe(observer);
```

##### fromCallable

```java
Observable.fromCallable(new Callable<Object>() {
    @Override
    public Object call() throws Exception {
        return "aaa";
    }
}).subscribe(observer);
```

##### fromFuture

```java
ArrayList<String> list = new ArrayList<>();
list.add("111");
list.add("222");
Observable.fromIterable(list)
        .subscribe(observer);

Observable.fromFuture(new Future<Object>() {
    @Override
    public boolean cancel(boolean mayInterruptIfRunning) {
        return false;
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Override
    public boolean isDone() {
        return false;
    }

    @Override
    public Object get() throws ExecutionException, InterruptedException {
        return "aaaa";
    }

    @Override
    public Object get(long timeout, TimeUnit unit) throws ExecutionException, InterruptedException, TimeoutException {
        return null;
    }
}).subscribe(observer);
```

##### formiterable

```java
//        ArrayList<String> list = new ArrayList<>();
//        list.add("111");
//        list.add("222");
//        Observable.fromIterable(list)
//                .subscribe(observer);
```



 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为`OnSubscribe`是通过`OnSubscribeToObservableFuture`进行的，Iterable转换通过`OnSubscribeFromIterable`进行。数组通过`OnSubscribeFromArray`转

#### just

 多个事件源，将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是`ScalarSynchronousObservable`对象。如果是多个对象，则是调用了from方法创建。



### 变换操作符

#### map

#### flatmap

 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。



### 合并操作符

















































换。

## ==Retrofit==



