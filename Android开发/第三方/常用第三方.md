## ==EventBus==

### 背景

常见的通信方式：广播（耗时（一般都是需要去拿到上下文的时候）），接口回调，binder，intent（对象序列化，传递的大小有限制，底层用的binder机制），handler（内存泄漏）

### 优点

1. 使用起来很简单
2. 实现解耦
3. jar包轻量
4. 稳定
5. 速度快
6. 线程切换方便

### 三个角色

1. Event： 它可以是任意类型，EventBus会根据事件类型进行全局的通知。
2. **Subscriber**：事件订阅者，在EventBus 3.0之前我们必须定义以onEvent开头的那几个方法，分别是`onEvent`、`onEventMainThread`、`onEventBackgroundThread`和`onEventAsync`，而在3.0之后事件处理的方法名可以随意取，不过需要加上注解`@subscribe`，并且指定线程模型，默认是`POSTING`。
3. **Publisher**：事件的发布者，可以在任意线程里发布事件。一般情况下，使用`EventBus.getDefault()`就可以得到一个EventBus对象，然后再调用`post(Object)`方法即可。

### 四种线程模型

1. **POSTING**：默认，表示事件处理函数的线程跟发布事件的线程在同一个线程。
2. **MAIN**：表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。
3. **BACKGROUND**：表示事件处理函数的线程在后台线程，因此不能进行UI操作。如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。
4. **ASYNC**：表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。

### 使用

####     	定义事件

首先要定义一个事件封装为对象，在程序的内部使用该对象作为通信的信息

```java
public class MessageWrap {

    public final String message;

    public static MessageWrap getInstance(String message) {
        return new MessageWrap(message);
    }

    private MessageWrap(String message) {
        this.message = message;
    }
}
```



####     		发布事件

```java
EventBus.getDefault().post(MessageWrap.getInstance(msg));
```



#### 接受事件



```java
@Subscribe(threadMode = ThreadMode.MAIN)
    public void onGetMessage(MessageWrap message) {
        getBinding().tvMessage.setText(message.message);
    }
```

### 	黏性事件

所谓的黏性事件就是指发送了该事件之后再来订阅的订阅者依然能够接收到的事件

### 使用

订阅者的不同

```java
//在注解的后面 再设置一个反射的值
@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)

```

发送者的方法不同

```java
 EventBus.getDefault().postSticky(MessageWrap.getInstance(msg));
```

### ==实现原理思想==

它的本质就是利用注册来保存订阅者的信息（这里通常包括已经添加注解的方法信息，且注解里面的线程信息，和单一的返回值类型），将他们保存在一个集合里面，把事件的类设计为单利模式，在需要发送事件的地方直接发送事件，然后并且刚才已经获得了注册类的信息也就是接受者 直接遍历 事件类里面的接收者集合，找到相同的参数信息，并且选择用反射来调用相应的方法就这样完成了 各个板块之间的通信。

### 性能调优==ATP==

主要就是把注册的地方换成注解处理器，不去使用反射来提升性能（使用注解处理器来生成模板代码，来提升性能）

### 优先级

在`Subscribe`注解中总共有3个参数  而第三个就是优先级参数

#### 注意

只有当两个订阅方法使用相同的`ThreadMode`参数的时候，它们的优先级才会与`priority`指定的值一致；

只有当某个订阅方法的`ThreadMode`参数为`POSTING`的时候，它才能停止该事件的继续分发。

```java
// 订阅方法，需要与上面的方法的threadMode一致，并且优先级略高
@Subscribe(threadMode = ThreadMode.POSTING, sticky = true, priority = 1)
public void onGetStickyEvent(MessageWrap message) {
    String txt = "Sticky event: " + message.message;
    getBinding().tvStickyMessage.setText(txt);
    if (stopDelivery) {
        // 终止事件的继续分发
        EventBus.getDefault().cancelEventDelivery(message);
    }
```

## ==Rxjava==

### 概述

Rxjava的链式调用可以保证逻辑的清晰

### 成员



![](https://upload-images.jianshu.io/upload_images/944365-4c1c1eb44ffe01e5.png)

![](https://upload-images.jianshu.io/upload_images/944365-331c1c459d00d986.png)



### 创建操作符

#### 用途

主要用来创建Observable（被观察者）

#### creat

 使用OnSubscribe从头创建一个Observable，这种方法比较简单。

```java
    Observable.create(new Observable.OnSubscribe<String>() {

        @Override
        public void call(Subscriber<? super String> subscriber) {

            subscriber.onNext("item1");
            subscriber.onNext("item2");
            subscriber.onCompleted();
        }
    });
```

#### from

##### fromArray

这里的每一个数据元素都会作为一个事件源产生

```java
Observable.fromArray("1", "AAAA", "2", "1", "AAAA", "2", "1", "AAAA", "2", "1", "AAAA", "2", "1", "AAAA", "2")
        .subscribe(observer);
```

##### fromCallable

```java
Observable.fromCallable(new Callable<Object>() {
    @Override
    public Object call() throws Exception {
        return "aaa";
    }
}).subscribe(observer);
```

##### fromFuture

```java
ArrayList<String> list = new ArrayList<>();
list.add("111");
list.add("222");
Observable.fromIterable(list)
        .subscribe(observer);

Observable.fromFuture(new Future<Object>() {
    @Override
    public boolean cancel(boolean mayInterruptIfRunning) {
        return false;
    }

    @Override
    public boolean isCancelled() {
        return false;
    }

    @Override
    public boolean isDone() {
        return false;
    }

    @Override
    public Object get() throws ExecutionException, InterruptedException {
        return "aaaa";
    }

    @Override
    public Object get(long timeout, TimeUnit unit) throws ExecutionException, InterruptedException, TimeoutException {
        return null;
    }
}).subscribe(observer);
```

##### formiterable

```java
//        ArrayList<String> list = new ArrayList<>();
//        list.add("111");
//        list.add("222");
//        Observable.fromIterable(list)
//                .subscribe(observer);
```



 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为`OnSubscribe`是通过`OnSubscribeToObservableFuture`进行的，Iterable转换通过`OnSubscribeFromIterable`进行。数组通过`OnSubscribeFromArray`转

#### just

 多个事件源，将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是`ScalarSynchronousObservable`对象。如果是多个对象，则是调用了from方法创建。

####  empty

创建一个什么都不做直接通知完成的Observable

#### **error**

： 创建一个什么都不做直接通知错误的Observable

#### **never**

创建一个什么都不做的Observable

```java
    Observable observable1=Observable.empty();//直接调用onCompleted。
    Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常
    Observable observable3=Observable.never();//啥都不做
```



#### **timer**

 创建一个在给定的延时之后发射数据项为0的`Observable<Long>`,内部通过`OnSubscribeTimerOnce`工作

```java
 Observable.timer(1000,TimeUnit.MILLISECONDS)
            .subscribe(new Action1<Long>() {
                @Override
                public void call(Long aLong) {
                    Log.d("JG",aLong.toString()); // 0
                }
            });
```

#### **interval**

  创建一个按照给定的时间间隔发射从0开始的整数序列的`Observable<Long>`，内部通过`OnSubscribeTimerPeriodically`工作。

```java
  Observable.interval(1, TimeUnit.SECONDS)
            .subscribe(new Action1<Long>() {
                @Override
                public void call(Long aLong) {
                     //每隔1秒发送数据项，从0开始计数
                     //0,1,2,3....
                }
            });
```

#### **range**

  创建一个发射指定范围的整数序列的`Observable<Integer>`

```java
 Observable.range(2,5).subscribe(new Action1<Integer>() {
        @Override
        public void call(Integer integer) {
            Log.d("JG",integer.toString());// 2,3,4,5,6 从2开始发射5个数据
        }
    });
```

#### **defer**

只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过`OnSubscribeDefer`在订阅时调用Func0创建Observable。

```java
  Observable.defer(new Func0<Observable<String>>() {
        @Override
        public Observable<String> call() {
            return Observable.just("hello");
        }
    }).subscribe(new Action1<String>() {
        @Override
        public void call(String s) {
            Log.d("JG",s);
        }
    });
```



### 变换操作符

#### **cast**

在发射之前强制将Observable发射的所有数据转换为指定类型



#### map

```java
// map: 对被观察者进行处理，把原来发射出来的事件进行处理并且产生新的事件，再次创建新的被观察者，发射事件
Observable.just("aaa")
        .map(new Function<String, Object>() {
            @Override
            public Object apply(@NonNull String s) throws Exception {
                return "BBBB";
            }
        }).subscribe(observer);
```

#### flatmap

 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。

//示例一

```java
       Observable.just(2,3,5)
            .flatMap(new Func1<Integer, Observable<String>>() {
                @Override
                public Observable<String> call(Integer integer) {
                    return Observable.create(subscriber -> {
                        subscriber.onNext(integer*10+"");
                        subscriber.onNext(integer*100+"");
                        subscriber.onCompleted();
                    });
                }
            })
    .subscribe(o -> Log.d("JG",o)) //20,200,30,300,50,500
```





```java
Observable.just("111", "222", "333", "444", "55")
        .flatMap(new Function<String, ObservableSource<?>>() {
            @Override
            public ObservableSource<?> apply(@NonNull String s) throws Exception {
                return Observable.just(s + "ssss");
            }
        }).subscribe(observer);
```

```java
//诠释map操作符和flat操作符的区别   对于多个事件的处理
//map
Observable.fromIterable(StudentModel.getStudents())
        .map(new Function<Student, List<Student.Course>>() {
            @Override
            public List<Student.Course> apply(@NonNull Student student) throws Exception {
                return student.getCourseList();
            }
        }).subscribe(new Consumer<List<Student.Course>>() {
    @Override
    public void accept(List<Student.Course> courseList) throws Exception {
        for (Student.Course course : courseList) {
            System.out.println(course);
        }
    }
});
//flatmap
Observable.fromIterable(StudentModel.getStudents())
        .flatMap(new Function<Student, ObservableSource<?>>() {
            @Override
            public ObservableSource<?> apply(@NonNull Student student) throws Exception {
                return Observable.fromIterable(student.getCourseList());
            }
        }).subscribe(new Consumer<Object>() {
    @Override
    public void accept(Object o) throws Exception {
        System.out.println(o);
    }
});
```



#### concatmap

基本上和flatmap一样的，但是它是有序的而flatmap是无序的

类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。

#### buffer



它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个

```java
// 网络请求场景当中常用的操作符
Observable.just("111", "222", "333", "444", "55", "666", "777", "888", "999", "AAAAA")
        .buffer(3)
        .subscribe(observer);
```

#### **flatMapIterable**

 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。

```java
        Observable.just(2,3,5)
            .flatMapIterable(new Func1<Integer, Iterable<String>>() {
                @Override
                public Iterable<String> call(Integer integer) {
                    return Arrays.asList(integer*10+"",integer*100+"");
                }
            }).subscribe(new Action1<String>() {
              @Override
              public void call(String s) {
            
              }
    });
```



#### **switchMap**

 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。

```java
  Observable.create(new Observable.OnSubscribe<Integer>() {

        @Override
        public void call(Subscriber<? super Integer> subscriber) {
            for(int i=1;i<4;i++){
                subscriber.onNext(i);
                Utils.sleep(500,subscriber);//线程休眠500ms
            }

            subscriber.onCompleted();
        }
    }).subscribeOn(Schedulers.newThread())
      .switchMap(new Func1<Integer, Observable<Integer>>() {
             @Override
           public Observable<Integer> call(Integer integer) {
                   //每当接收到新的数据，之前的Observable将会被取消订阅
                    return Observable.create(new Observable.OnSubscribe<Integer>() {
                        @Override
                        public void call(Subscriber<? super Integer> subscriber) {
                            subscriber.onNext(integer*10);
                            Utils.sleep(500,subscriber);
                            subscriber.onNext(integer*100);
                            subscriber.onCompleted();
                        }
                    }).subscribeOn(Schedulers.newThread());
                }
            })
            .subscribe(s -> Log.d("JG",s.toString()));//10,20,30,300
```

#### **scan**

 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。

```java
  Observable.just(2,3,5)
            .scan(new Func2<Integer, Integer, Integer>() {
                @Override
                public Integer call(Integer sum, Integer item) {
                    return sum+item;
                }
            })
    .subscribe(integer -> Log.d("JG",integer.toString())) //2,5,10
```

#### **groupBy**

将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。

```java
   Observable.just(2,3,5,6)
            .groupBy(new Func1<Integer, String>() {
                @Override
                public String call(Integer integer) {//分组
                    return integer%2==0?"偶数":"奇数";
                }
            })
    .subscribe(new Action1<GroupedObservable<String, Integer>>() {
        @Override
        public void call(GroupedObservable<String, Integer> o) {

            o.subscribe(new Action1<Integer>() {
                @Override
                public void call(Integer integer) {
                    Log.d("JG",o.getKey()+":"+integer.toString()); //偶数：2，奇数：3，...
                }
            });
        }
    })
```

#### **window**

定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。

### 组合操作符

##序连接多个Observables。需要注意的是`Observable.concat(a,b)`等价于`a.concatWith(b)`。

```java
    Observable<Integer> observable1=Observable.just(1,2,3,4);
    Observable<Integer>  observable2=Observable.just(4,5,6);

    Observable.concat(observable1,observable2)
            .subscribe(item->Log.d("JG",item.toString()));//1,2,3,4,4,5,6
```

#### **startWith**

 在数据序列的开头增加一项数据。`startWith`的内部也是调用了`concat`

```java
 Observable.just(1,2,3,4,5)
            .startWith(6,7,8)
    .subscribe(item->Log.d("JG",item.toString()));//6,7,8,1,2,3,4,5
```



#### **merge**

将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中`mergeDelayError`将异常延迟到其它没有错误的Observable发送完毕后才发射。而`merge`则是一遇到异常将停止发射数据，发送onError通知。



![](https://upload-images.jianshu.io/upload_images/1931185-57219b8f15ee8a93.png)



#### **zip**

使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过`OperatorZip`进行压.

```java
Observable<Integer>  observable1=Observable.just(1,2,3,4);
Observable<Integer>  observable2=Observable.just(4,5,6);
    Observable.zip(observable1, observable2, new Func2<Integer, Integer, String>() {
        @Override
        public String call(Integer item1, Integer item2) {
            return item1+"and"+item2;
        }
    })
    .subscribe(item->Log.d("JG",item)); //1and4,2and5,3and6
```

#### **combineLatest**

当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable==最近的数据==压合。具体请看下面流程图。

zip工作流程

![](https://upload-images.jianshu.io/upload_images/1931185-14134e499db9d0c4.png)

combineLatest工作流程

![](https://upload-images.jianshu.io/upload_images/1931185-1e60a8bf25b31e91.png)



### 功能操作符



```java
subscribeOn observeOn
```

```java
subscribeOn(Schedulers.newThread())// 主要来决定我执行subscribe方法所处的线程，也就是产生事件发射事件所在的线程
        .observeOn(AndroidSchedulers.mainThread())// 来决定下游事件被处理时所处的线程
```





### 过滤操作符

#### filter

 过滤数据。内部通过`OnSubscribeFilter`过滤数据。

```java
  Observable.just(3,4,5,6)
            .filter(new Func1<Integer, Boolean>() {
                @Override
                public Boolean call(Integer integer) {
                    return integer>4;
                }
            })
    .subscribe(item->Log.d("JG",item.toString())); //5,6 

```



#### **ofType**

过滤指定类型的数据，与filter类似，

```java
Observable.just(1,2,"3")
            .ofType(Integer.class)
            .subscribe(item -> Log.d("JG",item.toString()));
```



#### **take**

只发射开始的N项数据或者一定时间内的数据。内部通过`OperatorTake`和`OperatorTakeTimed`过滤数据。

```java
  Observable.just(3,4,5,6)
            .take(3)//发射前三个数据项
            .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据
```

#### **takeLas**

只发射最后的N项数据或者一定时间内的数据。内部通过`OperatorTakeLast`和`OperatorTakeLastTimed`过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。

```java
 Observable.just(3,4,5,6)
            .takeLast(3)
            .subscribe(integer -> Log.d("JG",integer.toString()));//4,5,6
```

#### **takeFirst**

提取满足条件的第一项。内部实现源码如下：

```java
public final Observable<T> takeFirst(Func1<? super T, Boolean> predicate) {
      return filter(predicate).take(1); //先过滤，后提取
}
```

#### **first/firstOrDefault**

只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。

```java
 Observable.just(3,4,5,6)
            .first()
            .subscribe(integer -> Log.d("JG",integer.toString()));//3
            
    Observable.just(3,4,5,6)
               .first(new Func1<Integer, Boolean>() {
                   @Override
                   public Boolean call(Integer integer) {
                       return integer>3;
                   }
               }) .subscribe(integer -> Log.d("JG",integer.toString()));//4
```

#### **last/lastOrDefaul**

只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。

#### **skip**

跳过开始的N项数据或者一定时间内的数据。内部通过`OperatorSkip`和`OperatorSkipTimed`实现过滤。

```java
  Observable.just(3,4,5,6)
               .skip(1)
            .subscribe(integer -> Log.d("JG",integer.toString()));//4,5,6
```

**kipLast**

跳过最后的N项数据或者一定时间内的数据。内部通过`OperatorSkipLast`和`OperatorSkipLastTimed`实现过滤。

#### **elementAt/elementAtOrDefault**

发射某一项数据，如果超过了范围可以的指定默认值。内部通过`OperatorElementAt`过滤。

```java
        Observable.just(3,4,5,6)
                 .elementAt(2)
        .subscribe(item->Log.d("JG",item.toString())); //5
```

#### **ignoreElements**

丢弃所有数据，只发射错误或正常终止的通知。内部通过`OperatorIgnoreElements`实现

#### **distinct**

过滤重复数据，内部通过`OperatorDistinct`实现。

```java
 Observable.just(3,4,5,6,3,3,4,9)
       .distinct()
      .subscribe(item->Log.d("JG",item.toString())); //3,4,5,6,9
```

#### **distinctUntilChanged**

过滤掉连续重复的数据。内部通过`OperatorDistinctUntilChanged`实现

```java
 Observable.just(3,4,5,6,3,3,4,9)
       .distinctUntilChanged()
      .subscribe(item->Log.d("JG",item.toString())); //3,4,5,6,3,4,9
```

#### **throttleFirst**

定期发射Observable发射的第一项数据。内部通过`OperatorThrottleFirst`实现。

```java
Observable.create(subscriber -> {
        subscriber.onNext(1);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(2);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }

        subscriber.onNext(3);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(4);
        subscriber.onNext(5);
        subscriber.onCompleted();

    }).throttleFirst(999, TimeUnit.MILLISECONDS)
            .subscribe(item-> Log.d("JG",item.toString())); //结果为1,3,4
```



#### **throttleWithTimeout/debounce**

发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时
 才进行发射

```java
 Observable.create(subscriber -> {
         subscriber.onNext(1);
         try {
             Thread.sleep(500);
         } catch (InterruptedException e) {
             throw Exceptions.propagate(e);
         }
         subscriber.onNext(2);
         try {
             Thread.sleep(500);
         } catch (InterruptedException e) {
             throw Exceptions.propagate(e);
         }

         subscriber.onNext(3);
         try {
             Thread.sleep(1000);
         } catch (InterruptedException e) {
             throw Exceptions.propagate(e);
         }
         subscriber.onNext(4);
         subscriber.onNext(5);
         subscriber.onCompleted();

     }).debounce(999, TimeUnit.MILLISECONDS)//或者为throttleWithTimeout(1000, TimeUnit.MILLISECONDS)
             .subscribe(item-> Log.d("JG",item.toString())); //结果为3,5
```

#### **sample/throttleLast**

定期发射Observable最近的数据。内部通过`OperatorSampleWithTime`实现。

```java
 Observable.create(subscriber -> {
        subscriber.onNext(1);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(2);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }

        subscriber.onNext(3);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(4);
        subscriber.onNext(5);
        subscriber.onCompleted();

    }).sample(999, TimeUnit.MILLISECONDS)//或者为throttleLast(1000, TimeUnit.MILLISECONDS)
            .subscribe(item-> Log.d("JG",item.toString())); //结果为2,3,5
```



#### **timeout**

如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。

```java
   Observable.create(( subscriber) -> {
        subscriber.onNext(1);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw Exceptions.propagate(e);
        }
        subscriber.onNext(2);
       
        subscriber.onCompleted();

    }).timeout(999, TimeUnit.MILLISECONDS,Observable.just(99,100))//如果不指定备用Observable将会抛出异常
            .subscribe(item-> Log.d("JG",item.toString()),error->Log.d("JG","onError")); //结果为1,99,100  如果不指定备用Observable结果为1,onError
}
```



### 条件操作符

#### **all**

  判断所有的数据项是否满足某个条件，内部通过`OperatorAll`实现。

```java
  Observable.just(2,3,4,5)
            .all(new Func1<Integer, Boolean>() {
                @Override
                public Boolean call(Integer integer) {
                    return integer>3;
                }
            })
    .subscribe(new Action1<Boolean>() {
        @Override
        public void call(Boolean aBoolean) {
            Log.d("JG",aBoolean.toString()); //false
        }
    })
    ;
```

#### **exists**

  判断是否存在数据项满足某个条件。内部通过`OperatorAny`实现

```java
   Observable.just(2,3,4,5)
            .exists(integer -> integer>3)
            .subscribe(aBoolean -> Log.d("JG",aBoolean.toString())); //true
```

#### **contains**

 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是`exists`

```java
  Observable.just(2,3,4,5)
            .contains(3)
            .subscribe(aBoolean -> Log.d("JG",aBoolean.toString())); //true
```

#### **sequenceEqual**

用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。

```java
 Observable.sequenceEqual(Observable.just(2,3,4,5),Observable.just(2,3,4,5))
            .subscribe(aBoolean -> Log.d("JG",aBoolean.toString()));//true
```



#### **isEmpty**

  用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。

```java
  Observable.just(3,4,5,6)
               .isEmpty()
              .subscribe(item -> Log.d("JG",item.toString()));//false
```

#### **amb**

  给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他Observable将会被忽略。

```java
    Observable<Integer> observable1=Observable.create(new Observable.OnSubscribe<Integer>() {
        @Override
        public void call(Subscriber<? super Integer> subscriber) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                subscriber.onError(e);
            }
            subscriber.onNext(1);
            subscriber.onNext(2);
            subscriber.onCompleted();
        }
    }).subscribeOn(Schedulers.computation());

    Observable<Integer> observable2=Observable.create(subscriber -> {
        subscriber.onNext(3);
        subscriber.onNext(4);
        subscriber.onCompleted();
    });

    Observable.amb(observable1,observable2)
    .subscribe(integer -> Log.d("JG",integer.toString())); //3,4
```

####**switchIfEmpty**

  如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。

```java
   Observable.empty()
            .switchIfEmpty(Observable.just(2,3,4))
    .subscribe(o -> Log.d("JG",o.toString())); //2,3,4
```



#### **defaultIfEmpty**

如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。

#### **takeUntil**

当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据

```java
 Observable.just(2,3,4,5)
            .takeUntil(new Func1<Integer, Boolean>() {
                @Override
                public Boolean call(Integer integer) {
                    return integer==4;
                }
            }).subscribe(integer -> Log.d("JG",integer.toString())); //2,3,4
```

#### **takeWhile**

当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。

```java
  Observable.just(2,3,4,5)
            .takeWhile(new Func1<Integer, Boolean>() {
                @Override
                public Boolean call(Integer integer) {
                    return integer==4;
                }
            })
            .subscribe(integer -> Log.d("JG",integer.toString())); //2,3
```

#### **skipUntil**

丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）

#### **skipWhile**

丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）



### 聚合操作符



#### **reduce**

对序列使用reduce()函数并发射最终的结果,内部使用`OnSubscribeReduce`实现。

```java
  Observable.just(2,3,4,5)
            .reduce(new Func2<Integer, Integer, Integer>() {
                @Override
                public Integer call(Integer sum, Integer item) {
                    return sum+item;
                }
            })
            .subscribe(integer -> Log.d("JG",integer.toString()));//14
```





#### **collect**

使用`collect`收集数据到一个可变的数据结构。

```java
  Observable.just(3,4,5,6)
               .collect(new Func0<List<Integer>>() { //创建数据结构

                   @Override
                   public List<Integer> call() {
                       return new ArrayList<Integer>();
                   }
               }, new Action2<List<Integer>, Integer>() { //收集器
                   @Override
                   public void call(List<Integer> integers, Integer integer) {
                       integers.add(integer);
                   }
               })
              .subscribe(new Action1<List<Integer>>() {
                  @Override
                  public void call(List<Integer> integers) {
                      
                  }
              });
```



#### **count/countLong**

计算发射的数量，内部调用的是`reduce`.

### 转换操作

#### **toList**

收集原始Observable发射的所有数据到一个列表，然后返回这个列表.

```java
    Observable.just(2,3,4,5)
            .toList()
            .subscribe(new Action1<List<Integer>>() {
                @Override
                public void call(List<Integer> integers) {
                    
                }
            });
```

#### **toSortedList**

收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表

```java
   Observable.just(6,2,3,4,5)
            .toSortedList(new Func2<Integer, Integer, Integer>() {//自定义排序
                @Override
                public Integer call(Integer integer, Integer integer2) {
                    return integer-integer2; //>0 升序 ，<0 降序
                }
            })
            .subscribe(new Action1<List<Integer>>() {
                @Override
                public void call(List<Integer> integers) {
                    Log.d("JG",integers.toString()); // [2, 3, 4, 5, 6]
                }
            });
```

#### **toMap**

将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。

```java
    Observable.just(6,2,3,4,5)
            .toMap(new Func1<Integer, String>() {
                @Override
                public String call(Integer integer) {
                    return "key：" + integer; //根据数据项生成map的key
                }
            }, new Func1<Integer, String>() {
                @Override
                public String call(Integer integer) {
                    return "value："+integer; //根据数据项生成map的kvalue
                }
            }).subscribe(new Action1<Map<String, String>>() {
        @Override
        public void call(Map<String, String> stringStringMap) {
            Log.d("JG",stringStringMap.toString()); // {key：6=value：6, key：5=value：5, key：4=value：4, key：2=value：2, key：3=value：3}
        }
    });
```

#### **toMultiMap**

类似于toMap，不同的地方在于map的value是一个集合。



























### Rxjava内存泄漏

产生的原因就是  耗时操作（比如网络请求，数据库等 数据还没有回来）

而干掉activity的操作，但由于线程还没有结束，所以导致activity没有被回收所以导致内存泄漏。

#### 解决一

并不推荐使用  因为当请求很多的事件 就要写很多的Disposable垃圾代码

首先需要配置  目的是为了 捕获异常

```java
public class MyApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        // 取消订阅后，抛出的异常无法捕获，导致程序崩溃
        RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
            @Override
            public void accept(Throwable throwable) throws Exception {
                Log.i("TAG", "setErrorHandler accept: throwable=" + throwable.toString());
            }
        });
    }
}
```

​	Rxjava的原码  subscribe 会返回一个Disposable类型

可以调用里面的disose方法  取消  可以解决

```java
@CheckReturnValue
@SchedulerSupport(SchedulerSupport.NONE)
public final Disposable subscribe(Consumer<? super T> onNext) {
    return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());
}
```

#### 解决二

利用感知生命周期来解决 内存泄漏的问题

先实现一个RxLifecycle

```java
public class RxLifecycle<T> implements LifecycleObserver, ObservableTransformer<T, T> {

    final CompositeDisposable compositeDisposable = new CompositeDisposable();

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    void onDestroy() {
        Log.i("TAG", "onDestroy: ");
        if (!compositeDisposable.isDisposed()) {
            compositeDisposable.dispose();
        }
    }

    @NonNull
    @Override
    public ObservableSource<T> apply(@NonNull Observable<T> upstream) {
        return upstream.doOnSubscribe(new Consumer<Disposable>() {
            @Override
            public void accept(Disposable disposable) throws Exception {
                compositeDisposable.add(disposable);
            }
        });
    }

    public static <T> com.dongnaoedu.rxjava.RxLifecycle<T> bindRxLifecycle(LifecycleOwner lifecycleOwner) {
        com.dongnaoedu.rxjava.RxLifecycle<T> lifecycle = new com.dongnaoedu.rxjava.RxLifecycle<>();
        lifecycleOwner.getLifecycle().addObserver(lifecycle);
        return lifecycle;
    }

}
```

第二步在环节当中使用这两个方法

```java
//这个是线程切换代码复用的封装
.compose(new com.dongnaoedu.rxjava.SchedulerTransformer<>())
    //解决内存泄漏问题的封装
.compose(com.dongnaoedu.rxjava.RxLifecycle.bindRxLifecycle(this))
```



==提优==

CompositeDisposable这个类 可以添加多个Disposable  一次性取消



#### compose

### 错误处理/重试机制

#### **onErrorResumeNext**

当原始Observable在遇到错误时，使用备用Observable。。

```java
  Observable.just(1,"2",3)
    .cast(Integer.class)
    .onErrorResumeNext(Observable.just(1,2,3))
    .subscribe(integer -> Log.d("JG",integer.toString())) //1,2,3
    ;
```

#### **onExceptionResumeNext**

当原始Observable在遇到异常时，使用备用的Observable。与`onErrorResumeNext`类似，区别在于`onErrorResumeNext`可以处理所有的错误，onExceptionResumeNext只能处理异常。

#### **onErrorReturn**

当原始Observable在遇到错误时发射一个特定的数据。

```java
 Observable.just(1,"2",3)
            .cast(Integer.class)
            .onErrorReturn(new Func1<Throwable, Integer>() {
                @Override
                public Integer call(Throwable throwable) {
                    return 4;
                }
            }).subscribe(new Action1<Integer>() {
        @Override
        public void call(Integer integer) {
            Log.d("JG",integer.toString());1,4
        }
    });
```

#### **retry**

当原始Observable在遇到错误时进行重试。

```java
    Observable.just(1,"2",3)
    .cast(Integer.class)
    .retry(3)
    .subscribe(integer -> Log.d("JG",integer.toString()),throwable -> Log.d("JG","onError"))
    ;//1,1,1,1,onError
```



#### **retryWhen**

当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是`retry`。

### 连接操作

`ConnectableObservable`与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。
 `ConnectableObservable.connect()`指示一个可连接的Observable开始发射数据.
 `Observable.publish()`将一个Observable转换为一个可连接的Observable
 `Observable.replay()`确保所有的订阅者看到相同的数据序列的`ConnectableObservable`，即使它们在Observable开始发射数据之后才订阅。
 `ConnectableObservable.refCount()`让一个可连接的Observable表现得像一个普通的Observable。

```java
       ConnectableObservable<Integer> co= Observable.just(1,2,3)
                .publish();

        co .subscribe(integer -> Log.d("JG",integer.toString()) );
        co.connect();//此时开始发射数据
```



### 阻塞操作

`BlockingObservable`是一个阻塞的Observable。普通的Observable 转换为 BlockingObservable，可以使用 `Observable.toBlocking( )`方法或者`BlockingObservable.from( )`方法。内部通过`CountDownLatch`实现了阻塞操作。。

以下的操作符可以用于BlockingObservable，如果是普通的Observable，务必使用Observable.toBlocking()转为阻塞Observable后使用，否则达不到预期的效果。

#### **forEach**

对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。

```java
Observable.just(2,3).observeOn(Schedulers.newThread()).toBlocking()
          .forEach(integer -> {
              Log.d("JG",integer.toString()+" "+Thread.currentThread().getName());
              Utils.sleep(500);
          });

Log.d("JG",Thread.currentThread().getName());
    // 2 RxNewThreadScheduler-1
    // 3 RxNewThreadScheduler-1
    // main
```



#### **first/firstOrDefault/last/lastOrDefault**：

这几个操作符之前有介绍过。也可以用于阻塞操作。

#### **single/singleOrDefault**：

如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。

**#### mostRecent**

：返回一个总是返回Observable最近发射的数据的Iterable。

**#### next**：

 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。

#### **latest**

 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值

**#### toFuture**

： 将Observable转换为一个Future

**#### toIterable**

：将一个发射数据序列的Observable转换为一个Iterable。

#### **getIterator**

：将一个发射数据序列的Observable转换为一个Iterator



### 工具集

#### **materialize**

将Observable转换成一个通知列表。

```java
 Observable.just(1,2,3)
           .materialize()
           .subscribe(new Action1<Notification<Integer>>() {
               @Override
               public void call(Notification<Integer> notification) {
                   Log.d("JG",notification.getKind()+" "+notification.getValue());
                   //OnNext 1
                   //OnNext 2
                   //OnNext 3
                   //OnCompleted null
               }
           });
```



#### **dematerialize**

与上面的作用相反，将通知逆转回一个Observable。

#### **timestamp**

给Observable发射的每个数据项添加一个时间戳。

```java
  Observable.just(1,2,3)
           .timestamp()
           .subscribe(new Action1<Timestamped<Integer>>() {
               @Override
               public void call(Timestamped<Integer> timestamped) {
                   Log.d("JG",timestamped.getTimestampMillis()+" "+timestamped.getValue());
                   //1472627510548 1
                   //1472627510549 2
                   //1472627510549 3
               }
           });
```

#### **timeInterval**

给Observable发射的两个数据项间添加一个时间差，实现在`OperatorTimeInterval`中

![](http://static.zybuluo.com/maplejaw/6dbl77xvh2z02hxil00juave/image_1argc8a1n17a61t441s5p1gln8231g.png)



#### **serialize**

： 强制Observable按次序发射数据并且要求功能是完好的

**#### cache**

： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者

#### **observeOn**

： 指定观察者观察Observable的调度器

**#### subscribeOn**

： 指定Observable执行任务的调度器

**#### doOnEach**

： 注册一个动作，对Observable发射的每个数据项使用

```java
   Observable.just(2,3)
             .doOnEach(new Action1<Notification<? super Integer>>() {
                 @Override
                 public void call(Notification<? super Integer> notification) {
                     Log.d("JG","--doOnEach--"+notification.toString());
                 }
             })
             .subscribe(integer -> Log.d("JG",integer.toString()));
 //结果为：            
  // --doOnEach--[rx.Notification@133c40b0 OnNext 2]
 // 2
  // --doOnEach--[rx.Notification@133c40b0 OnNext 3]
 // 3
// --doOnEach--[rx.Notification@df4db0e OnCompleted]
```

#### **doOnCompleted**

： 注册一个动作，对正常完成的Observable使用

**#### doOnError**

： 注册一个动作，对发生错误的Observable使用

**#### doOnTerminate**

：注册一个动作，对完成的Observable使用，无论是否发生错误

```java
  Observable.just(2,3)
            .doOnTerminate(new Action0() {
                @Override
                public void call() {
                    Log.d("JG","--doOnTerminate--");
                }
            })
            .subscribe(integer -> Log.d("JG",integer.toString()));
// 2 , 3 , --doOnTerminate--
```

#### **doOnSubscribe**

注册一个动作，在观察者订阅时使用。内部由`OperatorDoOnSubscribe`实现

![](http://static.zybuluo.com/maplejaw/9w3o5vxc0lzznbrpn4vwa78w/image_1argbe0o1atfqtbrj51gu0jho9.png)



**doOnUnsubscribe**： 注册一个动作，在观察者取消订阅时使用。内部由`OperatorDoOnUnsubscribe`实现，在`call`中加入一个解绑动作。

![](http://static.zybuluo.com/maplejaw/791vkq1lxpl2etqaql85a6e8/image_1argbhutoi1a1b6a18s9il6npvm.png)

#### **finallyDo/doAfterTerminate**

注册一个动作，在Observable完成时使用

```java
Observable.just(2,3)
            .doAfterTerminate(new Action0() {
                @Override
                public void call() {
                    Log.d("JG","--doAfterTerminate--");
                }
            })
            .subscribe(integer -> Log.d("JG",integer.toString()));
//2,3,  --doAfterTerminate-- 
```

#### **delay**

延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。



#### **delaySubscription**



延时处理订阅请求。实现在`OnSubscribeDelaySubscription`中

![](http://static.zybuluo.com/maplejaw/xqw7fto75revvct4zu3d56a5/image_1argc0tbetbj1rkj1etf4fcb1p13.png)



#### **using**

创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。

```java
  Observable.using(new Func0<File>() {//资源工厂
        @Override
        public File call() {

            File file = new File(getCacheDir(), "a.txt");
            if(!file.exists()){
                try {
                    Log.d("JG","--create--");
                    file.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return file;
        }
    }, new Func1<File, Observable<String>>() { //Observable
        @Override
        public Observable<String> call(File file) {
            return Observable.just(file.exists() ? "exist" : "no exist");
        }
    }, new Action1<File>() {//释放资源动作
        @Override
        public void call(File file) {
            if(file!=null&&file.exists()){
                Log.d("JG","--delete--");
                file.delete();
            }
        }
    })
    .subscribe(s -> Log.d("JG",s))
    ;
 //--create--
 //exist
 //--delete--
 
```

#### **single/singleOrDefault**

强制返回单个数据，否则抛出异常或默认数据



## ==Retrofit==

导入依赖

```java
    implementation 'com.squareup.retrofit2:retrofit:2.7.2' 
    implementation 'com.squareup.okhttp3:okhttp:4.4.1' 
    implementation 'com.squareup.okio:okio:2.4.3' 
    implementation 'com.squareup.retrofit2:converter-gson:2.7.2' 
    implementation 'com.squareup.retrofit2:adapter-rxjava2:2.7.2' 
    implementation 'com.squareup.okhttp3:logging-interceptor:4.4.1'
```



### 使用

先要定义一个接口，“描述每个网络请求的链接、请求方式、参数、请求头、返回的类型”，rxjava会根

据接口的这些描述，创建代理对象。

```java
public interface ApiService { // 类名随便起 @GET("users/list") // 跟主链接拼接后，成为完整的链接。 Call<User> getUsers(@Query String id); // 要明确返回类型，注解表明“是get的参数” @FormUrlEncoded // 使用@Field注解时必须要这句 @POST("users/list") Observable<User> getUsersO(@Field("id") String id); // 可以与rxjava连用 }
```

还可以在这里设置默认的OkHttpClient（因为retrofit内部是用okhttp实现的，所

有请求都是通过client创建的）

```java
Retrofit retrofit = new Retrofit.Builder()
        .baseUrl("http://localhost:4567/")
    // 添加反序列化工厂，Gson，可以自定义
    //Converter.Factory .addConverterFactory(GsonConverterFactory.create())
    //与Rxjava连用的方法
       // .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
    .client(new OkHttpClient().newBuilder()
           // 设置连接超时 
           .connectTimeout(5, TimeUnit.SECONDS) 
           // 设置拦截器 
           .addInterceptor(myInterceptor) 
           // 设置自动打log拦截器
           .addInterceptor(new HttpLoggingInterceptor())
        .build();
BlogService service = retrofit.create(BlogService.class);
Call<ResponseBody> call = service.getBlog(2);
// 用法和OkHttp的call如出一辙,
// 不同的是如果是Android系统回调方法执行在主线程
//异步使用   （接口回调）
call.enqueue(new Callback<ResponseBody>() {
    @Override
    public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
        try {
            System.out.println(response.body().string());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onFailure(Call<ResponseBody> call, Throwable t) {
        t.printStackTrace();
    }
});

//同步使用   
//同步方法（注意，此方法会使线程等待，直到得到网络请求结果）
Call<User> res = retrofit.create(ApiService.class).getUsers(); 
User u = res.execute().body(); // 直接根据网络请求返回的json，自动转化为对象
```

![](https://img-blog.csdn.net/20171231162846585?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvaGFvc2ly/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 方法注解

#### **GET**



```java
http://192.168.43.173/api/trades
//简单的get请求(没有参数)
 @GET("trades")
 Call<TradesBean> getItem();
```



```java
http://192.168.43.173/api/trades/{userId}
//简单的get请求(URL中带有参数)
  @GET("News/{userId}")
  Call<TradesBean> getItem(@Path("userId") String userId);
```



```java
//简单的get请求(URL中带有两个参数)
  @GET("News/{userId}")
  Call<TradesBean> getItem(@Path("userId") String userId,@Path("type") String type);
```

参数在url之后

```java
http://192.168.43.173/api/trades?userId={用户id}
//参数在url问号之后
 @GET("trades")
 Call<TradesBean> getItem(@Query("userId") String userId);
```



```java
http://192.168.43.173/api/trades?userId={用户id}&type={类型}
@GET("trades")
 Call<TradesBean> getItem(@QueryMap Map<String, String> map);


@GET("trades")
 Call<TradesBean> getItem(
                @Query("userId") String userId,
                @QueryMap Map<String, String> map);

```



#### **POST**



```java
http://192.168.43.173/api/trades/{userId}
//需要补全URL,post的数据只有一条reason
 @FormUrlEncoded
 @POST("trades/{userId}")
 Call<TradesBean> postResult(
         @Path("userId") String userId,
         @Field("reason") String reason;

```



```java
http://192.168.43.173/api/trades/{userId}?token={token}
//需要补全URL,问号后需要加token,post的数据只有一条reason
 @FormUrlEncoded
 @POST("trades/{userId}")
 Call<TradesBean> postResult(
         @Path("userId") String userId,
         @Query("token") String token,
         @Field("reason") String reason;


```



```java
//post一个对象
 @POST("trades/{userId}")
 Call<TradesBean> postResult(
         @Path("userId") String userId,
         @Query("token") String token,
         @Body TradesBean bean;

```

```java
//用不同注解post一个实体
 @POST("trades/{userId}")
 Call<TradesBean> postResult(
         @Part("entity") TradesBean bean;
```



#### **PUT**

```java
//put一个实体
 @PUT("trade/carInfo/{pid}")
 Call<TradesBean> putInfo(
             @Path("pid") Int pid,
             @Body CarInfoBean carInfoBean;)

```

#### **DELETE**



```java
http://192.168.43.173/api/trades/{userId}
//补全url
 @DELETE("trades/{userId}")
 Call<TradesBean> deleteInfo(
         @Path("userId") String userId;  
```



```java
http://192.168.43.173/api/trades/{userId}?token={token}
//补全url并且后面还token
 @DELETE("trades/{userId}")
 Call<TradesBean> deleteInfo(
         @Path("userId") String userId,
         @Query("token") String token;)  

```

Path是网址中的参数,例如:trades/{userId}
Query是问号后面的参数,例如:trades/{userId}?token={token}
QueryMap 相当于多个@Query
Field用于Post请求,提交单个数据,然后要加@FormUrlEncoded
Body相当于多个@Field,以对象的方式提交
@Streaming:用于下载大文件
@Header,@Headers、加请求头



### 标记注解

#### FormUrlEncoded

表示请求发送编码表单数据，每个键值对需要使用@Field注解

#### Multipart

表示发送multipart数据，需要配合使用@Part

#### Streaming

表示响应用字节流的形式返回，如果没使用该注解，默认会把数据全部载入到内存中，该注解在下载大文件时特别有用

### 参数注解

#### Headers

用于添加固定请求头，可以同时添加多个。通过该注解添加的请求头不会相互覆盖，而是工作存在

#### Header

作为方法的参数传入，用于添加不固定值的Header，该注解会更新已有的请求头



#### Body

多用于post请求发送非表单数据，比如想要以post方式传递json格式数据

#### Field

多用于post请求中表单字段，==Filed和FieldMap需要FormUrlEncoded结合使用==

#### FieldMap

和Filed作用一致，用于不确定表单参数



#### Part

用于表单字段，Part和PartMap与Multipart注解结合使用，适合文件上传的情况



#### PartMap

用于表单字段，Part和PartMap与Multpart注解结合使用，适合文件上传的情况



#### Query

用于Get中指定参数

#### QueryMap

多个Query



#### Path

用于url中的占位符

#### Url

用于指定请求路径

































































## OkHttp

### 简介

HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性：

- 支持HTTP/2，允许所有同一个主机地址的请求共享同一个socket连接
- 连接池减少请求延时
- 透明的GZIP压缩减少响应数据的大小
- 缓存响应内容，避免一些完全重复的请求

当网络出现问题的时候OkHttp依然坚守自己的职责，它会自动恢复一般的连接问题，如果你的服务有多个IP地址，当第一个IP请求失败时，OkHttp会交替尝试你配置的其他IP，OkHttp使用现代TLS技术(SNI, ALPN)初始化新的连接，当握手失败时会回退到TLS 1.0。

### 使用

```bash
implementation 'com.squareup.okhttp3:okhttp:3.10.0'
```

OkHttp的使用是非常简单的. 它的请求/响应 API 使用构造器模式builders来设计，它支持阻塞式的同步请求和带回调的异步请求。

#### 异步Get

new OkHttpClient;
 -构造Request对象；
 -通过前两步中的对象构建Call对象；
 -通过Call#enqueue(Callback)方法来提交异步请求

异步发起的请求会被加入到 `Dispatcher` 中的 `runningAsyncCalls`双端队列中通过线程池来执行

```java
String url = "http://wwww.baidu.com";
OkHttpClient okHttpClient = new OkHttpClient();
final Request request = new Request.Builder()
        .url(url)
        .get()//默认就是GET请求，可以不写
        .build();
Call call = okHttpClient.newCall(request);
call.enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        Log.d(TAG, "onFailure: ");
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        Log.d(TAG, "onResponse: " + response.body().string());
    }
});
```

#### 同步GET

前面几个步骤和异步方式一样，只是最后一部是通过 `Call#execute()` 来提交请求，注意这种方式会阻塞调用线程，所以在Android中应放在子线程中执行，否则有可能引起ANR异常，`Android3.0` 以后已经不允许在主线程访问网络。

```java
String url = "http://wwww.baidu.com";
OkHttpClient okHttpClient = new OkHttpClient();
final Request request = new Request.Builder()
        .url(url)
        .build();
final Call call = okHttpClient.newCall(request);
new Thread(new Runnable() {
    @Override
    public void run() {
        try {
            Response response = call.execute();
            Log.d(TAG, "run: " + response.body().string());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}).start();
```

#### POST方式提交String

这种方式与前面的区别就是在构造Request对象时，需要多构造一个RequestBody对象，用它来携带我们要提交的数据。在构造 `RequestBody` 需要指定`MediaType`，用于==描述请求/响应 `body` 的内容类型==，RequstBody的几种构造方式：

![](https://upload-images.jianshu.io/upload_images/3631399-304a944b5bef663e.png)

```java
MediaType mediaType = MediaType.parse("text/x-markdown; charset=utf-8");
String requestBody = "I am Jdqm.";
Request request = new Request.Builder()
        .url("https://api.github.com/markdown/raw")
        .post(RequestBody.create(mediaType, requestBody))
        .build();
OkHttpClient okHttpClient = new OkHttpClient();
okHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        Log.d(TAG, "onFailure: " + e.getMessage());
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        Log.d(TAG, response.protocol() + " " +response.code() + " " + response.message());
        Headers headers = response.headers();
        for (int i = 0; i < headers.size(); i++) {
            Log.d(TAG, headers.name(i) + ":" + headers.value(i));
        }
        Log.d(TAG, "onResponse: " + response.body().string());
    }
});
```

#### POST方式提交流

```java
RequestBody requestBody = new RequestBody() {
    @Nullable
    @Override
    public MediaType contentType() {
        return MediaType.parse("text/x-markdown; charset=utf-8");
    }

    @Override
    public void writeTo(BufferedSink sink) throws IOException {
        sink.writeUtf8("I am Jdqm.");
    }
};

Request request = new Request.Builder()
        .url("https://api.github.com/markdown/raw")
        .post(requestBody)
        .build();
OkHttpClient okHttpClient = new OkHttpClient();
okHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        Log.d(TAG, "onFailure: " + e.getMessage());
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        Log.d(TAG, response.protocol() + " " +response.code() + " " + response.message());
        Headers headers = response.headers();
        for (int i = 0; i < headers.size(); i++) {
            Log.d(TAG, headers.name(i) + ":" + headers.value(i));
        }
        Log.d(TAG, "onResponse: " + response.body().string());
    }
});
```

#### POST提交文件

```java
MediaType mediaType = MediaType.parse("text/x-markdown; charset=utf-8");
OkHttpClient okHttpClient = new OkHttpClient();
File file = new File("test.md");
Request request = new Request.Builder()
        .url("https://api.github.com/markdown/raw")
        .post(RequestBody.create(mediaType, file))
        .build();
okHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        Log.d(TAG, "onFailure: " + e.getMessage());
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        Log.d(TAG, response.protocol() + " " +response.code() + " " + response.message());
        Headers headers = response.headers();
        for (int i = 0; i < headers.size(); i++) {
            Log.d(TAG, headers.name(i) + ":" + headers.value(i));
        }
        Log.d(TAG, "onResponse: " + response.body().string());
    }
});
```

#### POST方式提交表单

```java
OkHttpClient okHttpClient = new OkHttpClient();
RequestBody requestBody = new FormBody.Builder()
        .add("search", "Jurassic Park")
        .build();
Request request = new Request.Builder()
        .url("https://en.wikipedia.org/w/index.php")
        .post(requestBody)
        .build();

okHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        Log.d(TAG, "onFailure: " + e.getMessage());
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        Log.d(TAG, response.protocol() + " " +response.code() + " " + response.message());
        Headers headers = response.headers();
        for (int i = 0; i < headers.size(); i++) {
            Log.d(TAG, headers.name(i) + ":" + headers.value(i));
        }
        Log.d(TAG, "onResponse: " + response.body().string());
    }
});
```

提交表单时，使用 `RequestBody` 的实现类`FormBody`来描述请求体，它可以携带一些经过编码的 `key-value` 请求体，键值对存储在下面两个集合中：

```dart
  private final List<String> encodedNames;
  private final List<String> encodedValues;
```

#### POST方式提交分块请求

MultipartBody 可以构建复杂的请求体，与HTML文件上传形式兼容。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如它的 `Content-Disposition` 。如果 `Content-Length` 和 `Content-Type` 可用的话，他们会被自动添加到请求头中。

```java
private static final String IMGUR_CLIENT_ID = "...";
private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");

private void postMultipartBody() {
    OkHttpClient client = new OkHttpClient();


    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
    MultipartBody body = new MultipartBody.Builder("AaB03x")
            .setType(MultipartBody.FORM)
            .addPart(
                    Headers.of("Content-Disposition", "form-data; name=\"title\""),
                    RequestBody.create(null, "Square Logo"))
            .addPart(
                    Headers.of("Content-Disposition", "form-data; name=\"image\""),
                    RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
            .build();

    Request request = new Request.Builder()
            .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
            .url("https://api.imgur.com/3/image")
            .post(body)
            .build();

    Call call = client.newCall(request);
    call.enqueue(new Callback() {
        @Override
        public void onFailure(Call call, IOException e) {

        }

        @Override
        public void onResponse(Call call, Response response) throws IOException {
            System.out.println(response.body().string());

        }

    });
}
```

#### ==拦截器-interceptor==

##### 拦截器的作用

拦截器可以拿到网络请求的 Request 对象和 Response 对象，有了这两个对象我们就可以对网络请求进行监听（打印日志）、缓存、修改 HTTP 的请求报文和响应报文。



OkHttp的拦截器链可谓是其整个框架的精髓，用户可传入的 `interceptor` 分为两类：
 ①一类是全局的 `interceptor`，该类 `interceptor` 在整个拦截器链中最早被调用，通过 `OkHttpClient.Builder#addInterceptor(Interceptor)` 传入；
 ②另外一类是非网页请求的 `interceptor` ，这类拦截器只会在非网页请求中被调用，并且是在组装完请求之后，真正发起网络请求前被调用，所有的 `interceptor` 被保存在 `List<Interceptor> interceptors` 集合中，按照添加顺序来逐个调用，具体可参考 `RealCall#getResponseWithInterceptorChain()` 方法。通过 `OkHttpClient.Builder#addNetworkInterceptor(Interceptor)` 传入；

这里举一个简单的例子，例如有这样一个需求，我要监控App通过 `OkHttp` 发出的所有原始请求，以及整个请求所耗费的时间，针对这样的需求就可以使用第一类全局的 `interceptor` 在拦截器链头去做。

```java
OkHttpClient okHttpClient = new OkHttpClient.Builder()
        .addInterceptor(new LoggingInterceptor())
        .build();
Request request = new Request.Builder()
        .url("http://www.publicobject.com/helloworld.txt")
        .header("User-Agent", "OkHttp Example")
        .build();
okHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        Log.d(TAG, "onFailure: " + e.getMessage());
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        ResponseBody body = response.body();
        if (body != null) {
            Log.d(TAG, "onResponse: " + response.body().string());
            body.close();
        }
    }
});
```

```java
public class LoggingInterceptor implements Interceptor {
    private static final String TAG = "LoggingInterceptor";
    
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request request = chain.request();

        long startTime = System.nanoTime();
        Log.d(TAG, String.format("Sending request %s on %s%n%s",
                request.url(), chain.connection(), request.headers()));

        Response response =  chain.proceed(request);

        long endTime = System.nanoTime();
        Log.d(TAG, String.format("Received response for %s in %.1fms%n%s",
                response.request().url(), (endTime - startTime) / 1e6d, response.headers()));

        return response;
    }
}
```

针对这个请求，打印出来的结果

```dart
Sending request http://www.publicobject.com/helloworld.txt on null
User-Agent: OkHttp Example
        
Received response for https://publicobject.com/helloworld.txt in 1265.9ms
Server: nginx/1.10.0 (Ubuntu)
Date: Wed, 28 Mar 2018 08:19:48 GMT
Content-Type: text/plain
Content-Length: 1759
Last-Modified: Tue, 27 May 2014 02:35:47 GMT
Connection: keep-alive
ETag: "5383fa03-6df"
Accept-Ranges: bytes
```

注意到一点是这个请求做了重定向，原始的 `request url` 是 `http://www.publicobject.com/helloworld.tx`，而响应的 `request url` 是 `https://publicobject.com/helloworld.txt`，这说明一定发生了重定向，但是做了几次重定向其实我们这里是不知道的，要知道这些的话，可以使用 `addNetworkInterceptor()`去做。更多的关于 `interceptor`的使用以及它们各自的优缺点，请移步OkHttp[官方说明文档](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsquare%2Fokhttp%2Fwiki%2FInterceptors)。

![](https://upload-images.jianshu.io/upload_images/3631399-164b722ab35ae9bf.png)

##### 哲哥讲的

作用:拦截器被用来对请求头进行添加、转换、删除，并且在需要时，使得请求短路。

```java
new HttpLoggingInterceptor()
```

- ```java
  addInterceptor( object : Interceptor { 
  override fun intercept(chain: Interceptor.Chain): Response {
  var retryCount = 0 
  var request =
  // 这里可以为“每个请求”统一添加header，实际上每一个请求都会 走这个拦截器，所以就一并添加上了（可以实现token的自动化管理，过期时自动刷新，特别方便）
  chain.request().newBuilder().header("token", "你的登 录token").build()
  // 尝试网络连接 
  var response = retry(request, chain) 
  // 如果失败则重试3次
  while (response?.isSuccessful != true && retryCount < retryNum) { 
  retryCount++
      response?.close() 
  response = retry(request, chain) 
  }
  return response 
  } 
  } ) 
  // end addInterceptor
  // 定义一个不会报错的请求函数
  fun retry(request: Request, chain: Interceptor.Chain): Response? { 
  // 注意必须要try-catch，否则有可能不会重试而直接抛异常（因为proceed方法会抛出 IOException） 
  return try {
  chain.proceed(request)
  } catch (e: Exception) {
  null 
  }
  }
  ```

那么，细心的你肯定注意到，拦截器是add进去的（addInterceptor），执行顺序是什么呢？

为什么直接return也不会影响后续interceptor的执行呢 ？

这里会有一个惯性思维：以为是你自定义的intercept执行完了，才会调用下一个interceptor的

intercept。实际上在你调用“chain.proceed(request)”时，就会请求下一个interceptor的intercept继续

对请求进行修饰和处理。

有关拦截器，这里推荐一篇文章：OkHttp Interceptor 入门到进阶 - 简书 (jianshu.com)



##### 博客

直接贴上博客的地址 [关于拦截器的大神博客](https://www.jianshu.com/p/1752753db538)



###### 使用

1. 实现 `Interceptor` 接口，重写 `intercept()` 函数获取并返回响应 `Response` 的对象。下面是一个日志打印的例子。

   ```java
   public class TestInterceptor implements Interceptor {
       private static final String TAG = "TestInterceptor";
   
       @Override
       public Response intercept(Chain chain) throws IOException {
           Log.d(TAG, "拦截器开始");
           // 获取请求对象
           Request request = chain.request();
           
           long t1 = System.nanoTime();
           Log.d(TAG, String.format("Sending request %s on %s%n%s",
                   request.url(), chain.connection(), request.headers()));
   
           // 发起HTTP请求，并获取响应对象
           Response response = chain.proceed(request);
   
           long t2 = System.nanoTime();
           Log.d(TAG, String.format("Received response for %s in %.1fms%n%s",
                   response.request().url(), (t2 - t1) / 1e6d, response.headers()));
   
           return response;
       }
   }
   ```

在建造 `OkHttpClient` 类的对象时调用 `addInterceptor()` 或 `addNetworkInterceptor()` 方法设置拦截器，下面的例子先使用 `addInterceptor()` 。

```java
    public void httpGetClick(View view) {
        String url = "https://publicobject.com/helloworld.txt";

        OkHttpClient okHttpClient = new OkHttpClient.Builder()
                .addInterceptor(new TestInterceptor())
                .build();

        final Request request = new Request.Builder()
                .url(url)
                .get() 
                .build();

        Call call = okHttpClient.newCall(request);
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                showData("onFailure: " + e.getMessage());
            }

            @Override
            public void onResponse(Call call, final Response response) throws IOException {
                String responseStr = (response.body() == null) ? "返回结果为空" : response.body().string();
                showData(responseStr);
            }
        });
    }
```

![](https://upload-images.jianshu.io/upload_images/3304008-3cdb5c36d34b2990.png)



###### addInterceptor 和 addNetworkInterceptor 的区别



1. **Application Interceptors**

- 使用 `addInterceptor()` 注册
- 有无网络都会被调用到
- `application` 拦截器只会被调用一次，调用 `chain.proceed()` 得到的是重定向之后最终的响应信息，不会通过 `chain.connection()` 获得中间过程的响应信息
- 允许 *short-circuit (短路)* 并且允许不去调用 `chain.proceed()` 请求服务器数据，可通过缓存来返回数据。

1. **Network Interceptors**

- 使用 `addNetworkInterceptor()` 注册
- 无网络时不会被调用
- 可以显示更多的信息，比如 OkHttp 为了减少数据的传输时间以及传输流量而自动添加的请求头 *Accept-Encoding: gzip* 希望服务器能返回经过压缩过的响应数据。
- `chain.connection()` 返回不为空的 `Connection` 对象可以查询到客户端所连接的服务器的IP地址以及TLS配置信息。

以下是使用 `Network Interceptors` 的代码

```java
        OkHttpClient okHttpClient = new OkHttpClient.Builder()
                .addNetworkInterceptor(new TestInterceptor())
                .build();

        final Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "OkHttp Example")
                .build();
```



![](https://upload-images.jianshu.io/upload_images/3304008-bcdc32b715507b5b.png)





#### 其他

1.推荐让 `OkHttpClient` 保持单例，用同一个 `OkHttpClient` 实例来执行你的所有请求，因为每一个 `OkHttpClient` 实例都拥有自己的连接池和线程池，重用这些资源可以减少延时和节省资源，如果为每个请求创建一个 `OkHttpClient` 实例，显然就是一种资源的浪费。当然，也可以使用如下的方式来创建一个新的 `OkHttpClient` 实例，它们共享连接池、线程池和配置信息。

```undefined
    OkHttpClient eagerClient = client.newBuilder()
        .readTimeout(500, TimeUnit.MILLISECONDS)
        .build();
    Response response = eagerClient.newCall(request).execute();
```

2.每一个Call（其实现是RealCall）只能执行一次，否则会报异常，具体参见 `RealCall#execute()`

## Glide

### 依赖

implementation 'com.github.bumptech.glide:glide:4.11.0' 

### 基础使用

```java
Glide.with(context)
// 此处建议传Activity或者Fragment，会和他们生命周期保持一致，例如： onPaused 时暂停加载，onResume 时又会自动重新加载 .load(url) .into(imageView);
```

### 占位图：

```java
Glide.with(context)
    .load(url)
    .placeholder(R.drawable.place_image) // 图片加载出来前，显示的图片
    .error(R.drawable.error_image) // 图片加载失败后，显示的图片 
    .into(imageView);
```

网络上的占位图

```java
DrawableRequestBuilder<String> thumbnailRequest = Glide.with(context)
.load(url2); 

Glide.with(context) 
.load(url1) 
.thumbnail(thumbnailRequest) 
// 相当于占位图通过url2获得。如果有一个预览图的链接（后 端同时给了个低质量的预览图片，则可以设置为url2）
.into(imageView);
```





### 缩略图

```java
Glide.with(context)
.load(url) 
.thumbnail(0.2f)
.into(imageView);
```

其实就是加载一个原图0.2倍的图片，通过采样率。但是网络请求一般是把图片流下载下来后，才设置

采样率转换为bitmap，所以这个方法对于大图比较有效。

### 裁剪

```java
Glide.with(context) 
    .load(url) 
    .override(width, height)
    .into(imageView);
```

# 下拉刷新库

https://www.cnblogs.com/foxy/p/7825073.html
