# 性能优化

## before

在内存和CPU的性能让都受到了一定的限制，无法做到像PC端那样具有超大内存和高性能的CPU。如果不加节制的使用内存和CPU资源，通常会导致如下情况：

- 过多的使用内存会导致内存溢出，即OOM
- 过多的使用CPU资源，一般是指做大量的耗时任务，会导致手机变得卡顿，甚至出现程序无法响应的情况，即ANR

## 布局优化

关于布局优化的思想很简单，就是尽量减少布局文件的层级。这个道理很浅显，布局中的层级少了，就意味着Android绘制时的工作量少了，那么程序的性能自然就提高了。

### 屏幕刷新机制

**为什么帧率要为60fps呢，因为人眼与大脑之间的协作无法感知超过60fps的画面更新。开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。**

#### **基本概念**

*在一个典型的显示系统中，一般包括==CPU==、==GPU==、==display==三个部分， CPU负责计算数据，把计算好数据交给GPU,GPU会对图形数据进行渲染，渲染好后放到buffer里存起来，然后display负责把buffer里的数据呈现到屏幕上。*

显示过程，简单的说就是CPU/GPU准备好数据，存入buffer，display每隔一段时间去buffer里取数据，然后显示出来。di==splay读取的频率是固定的==，比如每个16ms读一次，但是==CPU/GPU写数据是完全无规律的==。



**CPU 计算屏幕数据、GPU 进一步处理和缓存、最后 display 再将缓存中（buffer）的屏幕数据显示出来。**



#### Android

- 第一个步骤：**CPU 计算屏幕数据指的也就是 View 树的绘制过程，也就是 Activity 对应的视图树从根布局 DecorView 开始层层遍历每个 View，分别执行测量、布局、绘制三个操作的过程。**

- 我们常说的 Android 每隔 16.6ms 刷新一次屏幕其实是指：底层以固定的频率，比如每 16.6ms 将 buffer 里的屏幕数据显示出来。

- CPU 跟 Display 是不同的硬件，它们是可以并行工作的。要理解的一点是，**我们写的代码，只是控制让 CPU 在接收到屏幕刷新信号的时候开始去计算下一帧的画面工作**。而**底层在每一次屏幕刷新信号来的时候都会去切换这一帧的画面**，这点我们是控制不了的，是底层的工作机制
- 当我们的 app 界面没有必要再刷新时（比如==用户不操作了，当前界面也没动画==），这个时候，我们 app 是接收不到屏幕刷新信号的，所以也就不会让 CPU 去计算下一帧画面数据，但是底层仍然会以固定的频率来切换每一帧的画面，只是它后面切换的每一帧画面都一样，所以给我们的**感觉就是屏幕没刷新**。

Display 这一行可以理解成屏幕，所以可以看到，底层是以固定的频率发出 VSync 信号的，而这个固定频率就是我们常说的每 16.6ms 发送一个 VSync 信号

- *VSync –屏幕刷新的信号*

![img](https://upload-images.jianshu.io/upload_images/5815865-a449fb41ae9105f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1197)

- **CPU：**执行应用层的measure、layout、draw等操作，绘制完成后**将数据提交给GPU**
-  **GPU：**进一步处理数据，并将数据缓存起来
-  **屏幕：**由一个个像素点组成，以固定的频率（16.6ms，即1秒60帧）从缓冲区中取出数据来填充像素点

结合上面这张图，下面接着我再来看看 16.6 ms 屏幕刷新一次的意思：

**Display 这一行可以理解成屏幕**

**Display** 黄色的这一行里有一些数字：0, 1, 2, 3, 4，可以看到每次屏幕刷新信号到了的时候，数字就会变化，所以这些数字其实可以理解成每一帧屏幕显示的画面。也就是说，屏幕每一帧的画面可以持续 16.6ms，当过了 16.6ms，底层就会发出一个屏幕刷新信号，而屏幕就会去显示下一帧的画面。



**CPU** 这块的耗时其实就是我们 **app 绘制当前 View 树**的时间，而这段时间就跟我们**自己写的代码有关系**了，**如果你的布局很复杂，层次嵌套很多，每一帧内需要刷新的 View 又很多时，那么每一帧的绘制耗时自然就会多一点**。

**CPU ****蓝色这行里也有一些数字**，其实这些数字跟 Display 黄色的那一行里的数字是对应的，在 Display 里我们解释过这些数字表示的是每一帧的画面，那么在 CPU 这一行里，其实就是在计算对应帧的画面数据，也叫屏幕数据。也就是说，在当前帧内，CPU 是在计算下一帧的屏幕画面数据，当屏幕刷新信号到的时候，屏幕就去将 CPU 计算的屏幕画面数据显示出来；同时 CPU 也接收到屏幕刷新信号，所以也开始去计算下一帧的屏幕画面数据。

- 再继续看图
- 因为我们的 app 界面不需要刷新了（用户不操作了，界面也没有动画），那么这之后我们 app 就不会再接收到屏幕刷新信号了，所以也就不会再让 CPU 去绘制视图树来计算下一帧画面了。但是，底层还是会每隔 16.6ms 发出一个屏幕刷新信号，只是我们 app 不会接收到而已，Display 还是会在每一个屏幕刷新信号到的时候去显示下一帧画面，只是下一帧画面一直是第4帧的内容而已。



#### 普通刷新机制



![img](https://upload-images.jianshu.io/upload_images/5815865-07e9e14c3c972c8e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)



#### 双缓冲机制

看完上面的流程图，我们很容易想到一个问题，屏幕是以16.6ms的固定频率进行刷新的，但是我们应用层触发绘制的时机是完全随机的（比如我们随时都可以触摸屏幕触发绘制），**如果在GPU向缓冲区写入数据的同时，屏幕也在向缓冲区读取数据，会发生什么情况呢？**

**有可能屏幕上就会出现一部分是前一帧的画面，一部分是另一帧的画面，这显然是无法接受的，那怎么解决这个问题呢？**

这个其实和我们平时使用代码管理工具Git的一些思路有相似之处**，首先我们有一个master分支，对应线上版本的代码，当有新的需求来的时候，我们往往不会在master分支上直接进行开发，都会拉出一个新的分支，比如develop分支，在develop分支上开发新需求，等开发完成测试通过后才会合并到master分支**



- GPU只向Back Buffer中写入绘制数据，且GPU会定期交**换Back Buffer和Frame Buffer**，也就是让Back Buffer 变成Frame Buffer交给屏幕进行绘制，**让原先的Frame Buffer变成Back Buffer进行数据写入**。

- 交换的频率也是60次/秒，这就与屏幕的刷新频率保持了同步。

![img](https://upload-images.jianshu.io/upload_images/5815865-e9a147cd72ddc304.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

虽然我们引入了双缓冲机制，但是我们知道，当布局比较复杂，或设备性能较差的时候，CPU并不能保证在16.6ms内就完成绘制数据的计算，所以这里系统又做了一个处理。



**丢帧**

**当你的应用正在往Back Buffer中填充数据时，系统会将Back Buffer锁定。如果到了GPU交换两个Buffer的时间点，你的应用还在往Back Buffer中填充数据，GPU会发现Back Buffer被锁定了，它会放弃这次交换。**

这样做的后果就是手机屏幕仍然显示原先的图像，这就是我们常常说的==丢帧==，所以为了避免丢帧的发生，我们就要尽量**减少布局层级**，**减少不必要的View的invalidate调用**，**减少大量对象的创建**（GC也会占用CPU时间）等等。



### 过度绘制



Overdraw（过度绘制）：描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，就会导致某些像素区域被绘制了多次，浪费大量的CPU以及GPU资源。（可以通过开发者选项，打开Show GPU Overdraw的选项，观察UI上的Overdraw情况）。



![img](https://images2015.cnblogs.com/blog/1086572/201701/1086572-20170104111351675-1993963814.png)

蓝色、淡绿、淡红，深红代表了4种不同程度的Overdraw的情况，我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190424171442118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NpbW9uX0NyeXN0aW4=,size_16,color_FFFFFF,t_70)

### 优化方案







#### 善用相对布局Relativelayout



在RelativeLayout和LinearLayout同时能够满足需求时，尽量使用RelativeLayout，这一点可以从我们MainActivity默认布局就可以看出，默认是RelativeLayout，因为可以通过扁平的RelativeLayout降低LinearLayout嵌套所产生布局树的层级。
　　Android提供了几种方便的布局管理器，大多数时候，你只需要这些布局的一部分基本特性去实现UI。 一般情况下用LinearLayout的时候总会比RelativeLayout多一个View的层级。而每次往应用里面增加一个View，或者增加一个布局管理器的时候，都会增加运行时对系统的消耗，因此这样就会导致界面初始化、布局、绘制的过程变慢。还是举个例子吧，先看一下布局图。
　　首先用LinearLayout方式来实现：

![img](https://images2015.cnblogs.com/blog/1086572/201701/1086572-20170104112011378-2121162267.png)

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
 
    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="10dp"
        android:src="@mipmap/ic_launcher" />
 
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">
 
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginLeft="10dp"
            android:layout_marginTop="16dp"
            android:text="这个是LinearLayout"
            android:textSize="16sp" />
 
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginLeft="10dp"
            android:layout_marginTop="10dp"
            android:text="这个是LinearLayout,这个是LinearLayout"
            android:textSize="12sp" />
    </LinearLayout>
 
</LinearLayout>
```

接着是RelativeLayout方式:

![img](https://images2015.cnblogs.com/blog/1086572/201701/1086572-20170104112224112-1520535244.png)

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
 
    <ImageView
        android:id="@+id/iv_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="10dp"
        android:src="@mipmap/ic_launcher" />
 
    <TextView
        android:id="@+id/tv_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginLeft="10dp"
        android:layout_marginTop="16dp"
        android:layout_toRightOf="@+id/iv_image"
        android:text="这个是LinearLayout"
        android:textSize="16sp" />
 
    <TextView
        android:id="@+id/tv_content"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@+id/tv_title"
        android:layout_marginLeft="10dp"
        android:layout_marginTop="10dp"
        android:layout_toRightOf="@+id/iv_image"
        android:text="这个是LinearLayout,这个是LinearLayout"
        android:textSize="12sp" />
 
</RelativeLayout>
```



#### 使用抽象布局标签





##### include标签



　include标签常用于将布局中的公共部分提取出来。

**个人观点系列**

-   我觉得这个东西它对布局嵌套的层次 没什么优化（如果有优化也是开发者的思路更加清晰）

- 它主要所作的优化就是重用layout布局  减少资源的浪费和清晰的逻辑思维

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/activity_main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="com.jared.layoutoptimise.MainActivity">
 
    <include layout="@layout/item_test_linear_layout" />
     
</RelativeLayout>
```



##### merge标签



merge标签可以降低UI层级

**注意：**

- 1.<merge />只可以作为xml layout的根节点。
-  2.当需要inflate的xml layout本身是由merge作为根节点的话，需要将被导入的xml layout置于viewGroup中，同时需要设置attachToRoot为True。



<merge>标签多用于==替换FrameLayout==或者当一个布局包含另外一个布局时，<merge>标签用于消除父子层次结构中多余的视图组。例如：我们建立的一个布局是垂直的，此时如果引入另外一个垂直布局的<include>，这时如果include布局使用的LinearLayout就没意义了，使用的话反而会减慢UI表现。这时我们可以使用<merge>标签，**它可以排除一个布局插入另外一个布局时产生的多余的ViewGroup。具体用法如下**



==1.用法1替换FrameLayout==



```xml
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="我是button" />

    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="我又是个button" />

</merge>
```



==2.用法2插入布局时消除多余的视图组==



```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <include layout="@layout/fragment_main" />

</LinearLayout>
```



其中fragment_main是用法1中的布局，这时我们能看到按钮是垂直排列的。

**注意：**

- ​     <merge>**只能作为xml布局的根标签使用**，**当Inflate以<merge>开头的布局文件时，必须指定一个父ViewGroup并且必须设定attachToBoot为true。**



##### ViewStub

**<ViewStub>标签最大的特点就是你需要的时候才会加载**，**并且不会影响UI初始化的性能。一些不常用的布局文件如显示错误信息的diaolog，这时都可以用<ViewStub>标签进行优化。**

* **有人也许会说，我用View.GONE也可以达到相同的效果呀？那么两者有什么区别呢？**

​      <VewStub>只能**inflate一次**，**用完以后<ViewStub>就会置空**，**后期不能再次使用，只有重新开启应用或者杀死进程后才可再次使用**。

- 类似显示隐藏按钮这种功能是不能实现的。**View.GONE比较费资源，虽然已经GONE掉了，但显示View时还是会加载的**

**使用场景**

各种不常用的布局文件如进度条、显示错误信息等可以使用<ViewStub />标签以减少内存使用量，加快渲染速度。<ViewStub />标签是一个不可见的，大小为0的View。

2、实现View的延迟加载，避免浪费资源，在你需要的时候实行加载。



[Android UI优化之ViewStub标签的使用](https://blog.csdn.net/u012721519/article/details/51231469)



#### ConstaintLayout

这个布局可以大大减少view的嵌套   但是可能到了复杂布局的

时候 是那种牵一发而动全身的感觉

- 这个布局在复杂布局上面比传统布局性能要好

- 简单布局如果也使用约束布局的话，性能不如线性布局这些

这个布局现在也也到了2.0的版本 提供了很多新的功能

比如：**Montion Layout**

## 绘制优化

减少绘制的速度

### 方向

- 降低View.onDraw（）的复杂度
- 避免过度绘制（Overdraw）

### 方案

#### onDraw（）中不要创建新的局部对象



![在这里插入图片描述](https://img-blog.csdnimg.cn/20190424171253311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NpbW9uX0NyeXN0aW4=,size_16,color_FFFFFF,t_70)

####  避免onDraw（）执行大量 & 耗时操作

#### 避免过度绘制

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190424171442118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NpbW9uX0NyeXN0aW4=,size_16,color_FFFFFF,t_70)

**原则**

​    ==主要几个方面就是移除背景  包括window窗口的背景   控件的背景    布局文件的层级  自定义view看不见的地方就把它裁剪了==

1. 尽可能地控制 过度绘制的次数 = 2 次（绿色）以下，蓝色最理想
2. 尽可能避免 过度绘制的粉色 & 红色情况
3. 不允许 3 次以上的过度绘制（淡红色）面积 超过 屏幕大小的 1/4

**优化方案1： 移除默认的 Window 背景**

- 背景
  一般应用程序 默认 继承的主题 = windowBackground ，如默认的 Light 主题：

```xml
<style name="Theme.Light">
    <item name="isLightTheme">true</item>
    <item name="windowBackground">@drawable/screen_background_selector_light</item>
    ...
</style>
```



- 问题
  一般情况下，该默认的 Window 背景基本用不上：**因背景都自定义设置
  若不移除，则导致所有界面都多 1 次绘制**
- 解决方案
  移除默认的 Window 背景



```java
// 方式1：在应用的主题中添加如下的一行属性
    <item name="android:windowBackground">@android:color/transparent</item>
    <!-- 或者 -->
    <item name="android:windowBackground">@null</item>

// 方式2：在 BaseActivity 的 onCreate() 方法中使用下面的代码移除
    getWindow().setBackgroundDrawable(null);
    <!-- 或者 -->
    getWindow().setBackgroundDrawableResource(android.R.color.transparent);
```

**优化方案2：移除 控件中不必要的背景**



如2个常见场景：

- 场景1：ListView 与 Item
  列表页（ListView） 与 其内子控件（Item）的背景相同 = 白色，故可移除子控件（Item）布局中的背景



![在这里插入图片描述](https://img-blog.csdnimg.cn/20190424173854744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NpbW9uX0NyeXN0aW4=,size_16,color_FFFFFF,t_70)



- 场景2：ViewPager 与 Fragment
  对于1个ViewPager + 多个 Fragment 组成的首页界面，若每个
  Fragment 都设有背景色，即 ViewPager 则无必要设置，可移除

**优化方案3：减少布局文件的层级（减少不必要的嵌套）**



- 原理：减少不必要的嵌套 ->> UI层级少 ->> 过度绘制的可能性低
- 优化方式：使用布局标签 & 合适选择布局类型



**优化方案4：自定义控件View优化：使用 clipRect() 、 quickReject()**



- clipRect()

1. 作用：给 Canvas 设置一个裁剪区域，只有在该区域内才会被绘制，区域之外的都不绘制
2. 实例说明：DrawerLayout 布局 = 左抽屉布局



![在这里插入图片描述](https://img-blog.csdnimg.cn/20190424174208308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NpbW9uX0NyeXN0aW4=,size_16,color_FFFFFF,t_70)





```java
@Override
protected boolean drawChild(Canvas canvas, View child, long drawingTim
    // ...仅贴出关键代码

        // 1. 遍历 DrawerLayout 的 child view，拿到抽屉布局
        for (int i = 0; i < childCount; i++) {
            final View v = getChildAt(i);
            if (v == child || v.getVisibility() != VISIBLE
                    || !hasOpaqueBackground(v) || !isDrawerView(v)
                    || v.getHeight() < height) {
                continue;
            }
            // a. 若是左抽屉布局
            // 则取抽屉布局的右边界作为裁剪区的左边界、设置原主布局的裁剪区域，如上图裁剪区域
            if (checkDrawerViewAbsoluteGravity(v, Gravity.LEFT)) {
                final int vright = v.getRight();
                if (vright > clipLeft) clipLeft = vright;
            // b. 若是右抽屉布局
            // 则取抽屉布局的左边界作为裁剪区的右边界、设置原主布局的裁剪区域
            } else {
                final int vleft = v.getLeft();
                if (vleft < clipRight) clipRight = vleft;
            }
        }
        // 2. 通过clipRect（）设置原主布局的显示范围 = 裁剪区域，使其仅在上图中的红框区域（即不阻碍抽屉布局的区域）显示
       // 从而避免过度绘制
        canvas.clipRect(clipLeft, 0, clipRight, getHeight());
    }
    ......                       
}
```



- quickreject()

1. 作用：判断和某个矩形相交
2. 具体措施：若判断与矩形相交，则可跳过相交的区域，从而减少过度绘制













## 内存泄漏优化

### 是什么

内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，

- 首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；
- 其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象==不会被GC所回收，然而它却占用内存==。

### 原因

即某个对象已经不需要再用了，但是它却没有被系统所回收，一直在内存中占用着空间，而导致它无法被回收的原因大多是由于它被一个生命周期更长的对象所引用。

一句话总结

**生命周期较长的对象持有生命周期较短的对象的引用。**

### 举例

如果一个 Activity 被一个单例对象所引用，那么当退出这个 Activity 时，由于单例的对象依然存在（==单例对象的生命周期跟整个 App 的生命周期一致==），而单例对象又持有 Activity 的引用，这就导致了此 Activity 无法被回收，从而造成内存泄漏。

### 实例

#### handler

==handler为什么会造成内存泄漏？==

主线程的Looper对象不断从消息队列中取出消息，然后再交给Handler处理。如果在Activity中的Handler不是静态的，那么Handler肯定是持有Activity的引用。**而每个Message对象是持有Handler的引用的**（Message对象的**target属性持有Handler引用**），从而导致Message间接引用到了Activity。如果在Activity destroy之后，消息队列中还有Message对象，Activity是不会被回收的。

**解决方法**：静态Handler，如果要持有引用，要写成弱引用，在Activity被释放的时候要清空Message，取消Handler的

Runnable

#### 单例造成的内存泄漏

```java
public class SingleTon {
    
    private static SingleTon singleTon;

    private Context context;

    private SingleTon(Context context) {
        this.context = context;
    }

    public static SingleTon getInstance(Context context) {
        if (singleTon == null) {
            synchronized (SingleTon.class) {
                if (singleTon == null) {
                    singleTon = new SingleTon(context);
                }
            }
        }
        return singleTon;
    }

}
}
```

- 这是单例模式饿汉式的双重校验锁的写法，这里的 singleTon 持有 Context 对象，**如果 Activity 中调用  getInstance 方法并传入 this 时，singleTon 就持有了此 Activity 的引用，当退出 Activity  时，Activity 就无法回收，造成内存泄漏**，所以应该修改它的构造方法

```java
private SingleTon(Context context) {
    this.context = context.getApplicationContext();
}
```

- 通过 getApplicationContext 来获取 Application 的 Context，让它被单例持有，这样退出 Activity 时，Activity 对象就能正常被回收了，而 Application 的 Context 的生命周期和单例的生命周期是一致的（==也就是与整个app的生命周期是一致的==），所有再整个 App 运行过程中都不会造成内存泄漏。

#### 非静态内部类造成的内存泄漏

我们知道，非静态内部类会持有外部类的引用，**如果这个非静态的内部类的生命周期比它的外部类的生命周期长**，那么当销毁外部类的时候，它无法被回收，就会造成内存泄漏。

#### 外部类中持有非静态内部类的静态对象

假设 Activity 的代码是这样的

```java
public class MainActivity extends AppCompatActivity {
    
    private static Test test;    //静态的对象
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (test == null) {
            test = new Test();
        }

    }
    
    private class Test {

    }
    
}
```

这个其实和单例的原理是一样的，由于**静态对象 test 的生命周期和整个应用的生命周期一致**，**而非静态内部类 Test 持有外部类 MainActivity 的引用**，导致 MainActivity 退出的时候不能被回收，从而造成内存泄漏，解决的方法也很简单，把 test 改成非静态，这样 test 的生命周期和 MainActivity 是一样的了，就避免了内存泄漏。或者也可以把 Test 改成静态内部类，让 test 不持有 MainActivity 的引用，不过一般没有这种操作。

#### Handler 或 Runnable 作为非静态内部类

**handler 和 runnable 都有定时器的功能，当它们作为非静态内部类的时候**，同样会持有外部类的引用，如果它们的内部有延迟操作，在延迟操作还没有发生的时候，销毁了外部类，那么外部类对象无法回收，从而造成内存泄漏，假设 Activity 的代码如下:

**就比如郭神让我用post去拿view的宽度的时候 也是有可能造成内存泄漏的**

具体些的话 我就放一篇博客在这里吧！

[View#post与Handler#post的区别，以及导致的内存泄漏分析_良秋的专栏-CSDN博客_handler post](https://blog.csdn.net/a740169405/article/details/69668957)

```java
public class MainActivity extends AppCompatActivity {
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                
            }
        }, 10 * 1000);
    }
}
```

handler 和 runnable 都有定时器的功能，当它们作为非静态内部类的时候，**同样会持有外部类的引用，如果它们的内部有延迟操作，在延迟操作还没有发生的时候，销毁了外部类，那么外部类对象无法回收，从而造成内存泄漏**，假设 Activity 的代码如下

```java
public class MainActivity extends AppCompatActivity {
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                
            }
        }, 10 * 1000);
    }
}
```

上面的代码中，Handler 和 Runnable 作为匿名内部类，都会**持有 MainActivity 的引用**，而它们内部有一个 10 秒钟的定时器，如果在打开 MainActivity 的 10 秒内关闭了 MainActivity，那么由于 Handler 和 Runnable 的生命周期比 MainActivity 长，会导致 MainActivity 无法被回收，从而造成内存泄漏。

那么应该如何避免内存泄漏呢？这里的一般套路就是把 Handler 和 Runnable 定义为静态内部类，这样它们就不再持有 MainActivity 的引用了，从而避免了内存泄漏

```java
public class MainActivity extends AppCompatActivity {

    private Handler handler;

    private Runnable runnable;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        handler = new TestHandler();
        runnable = new TestRunnable();
        handler.postDelayed(runnable, 10 * 1000);
    }

    private static class TestHandler extends Handler {

    }

    private static class TestRunnable implements Runnable {
        @Override
        public void run() {
            Log.d(TAG, "run: ");
        }
    }
    
    private static final String TAG = "MainActivity";
}
```

**最好再在 onDestory 调用 handler 的 removeCallbacks 方法来移除 Message，这样不但能避免内存泄漏，而且在退出 Activity 时取消了定时器，保证 10 秒以后也不会执行 run 方法**

```java
@Override
protected void onDestroy() {
    super.onDestroy();
    handler.removeCallbacks(runnable);
}
```

```java
@Override
protected void onDestroy() {
    super.onDestroy();
    handler.removeCallbacks(runnable);
}
```

还有一种特殊情况，如果 Handler 或者 Runnable 中持有 Context 对象，那么即使使用静态内部类，还是会发生内存泄漏

```java
public class MainActivity extends AppCompatActivity {

    private Handler handler;

    private Runnable runnable;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        handler = new TestHandler(this);
        runnable = new TestRunnable();
        handler.postDelayed(runnable, 10 * 1000);
    }

    private static class TestHandler extends Handler {
        private Context context;
        private TestHandler(Context context) {
            this.context = context;   //虽然是静态 但是持有
        }
    }

    private static class TestRunnable implements Runnable {
        @Override
        public void run() {
            Log.d(TAG, "run: ");
        }
    }

    private static final String TAG = "MainActivity";
}
```

上面的代码，使用 [leakcanary](https://link.jianshu.com?t=https://github.com/square/leakcanary) 工具会发现依然会发生内存泄漏，而且造成内存泄漏的原因和之前用非静态内部类是一样的，那么为什么会出现这种情况呢？



**这里就是自己传进入的context对象**

这是由于在 Handler 中持有 Context 对象，而这个 Context 对象是通过 TestHandler 的构造方法传入的，它是一个 MainActivity 对象，也就是说，虽然 TestHandler 作为静态内部类不会持有外部类 MainActivity 的引用，但是我们在调用它的构造方法时，自己传入了 MainActivity 的对象，从而 handler 对象持有了 MainActivity 的引用，handler 的生命周期比 MainActivity 的生命周期长，因此会造成内存泄漏，这种情况可以使用弱引用的方式来引用 Context 来避免内存泄漏，代码如下

```java
public class MainActivity extends AppCompatActivity {

    private Handler handler;

    private Runnable runnable;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        handler = new TestHandler(new WeakReference<Context>(this));
        runnable = new TestRunnable();
        handler.postDelayed(runnable, 10 * 1000);
    }

    private static class TestHandler extends Handler {
        private Context context;
        private TestHandler(WeakReference<Context> weakContext) {
            context = weakContext.get();
        }
    }

    private static class TestRunnable implements Runnable {
        @Override
        public void run() {
            Log.d(TAG, "run: ");
        }
    }

    private static final String TAG = "MainActivity";
}
```

#### 其他

还有一些其他的会导致内存泄漏的情况，比如 BraodcastReceiver 未取消注册，InputStream 未关闭等，这类内存泄漏非常简单，只要在平时写代码时多多注意即可避免。

### 引用类型

#### 特性

| 引用类型 | 取得目标对象方式 | 垃圾回收条件   | 是否可能内存泄漏 |
| -------- | ---------------- | -------------- | ---------------- |
| 强引用   | 直接调用         | 不回收         | 可能             |
| 软引用   | 通过 get() 方法  | 视内存情况回收 | 不可能           |
| 弱引用   | 通过 get() 方法  | 永远回收       | 不可能           |
| 虚引用   | 无法取得         | 不回收         | 可能             |

## 响应速度优化

**响应速度优化的核心思想**：**就是避免在主线程中做耗时操作**。

- 如果有耗时操作，可以开启子线程执行，即采用异步的方式来执行耗时操作。

- 如果在主线程中做太多事情，会导致Activity启动时出现黑屏现象，甚至ANR。

- Android规定，Activity如果5秒钟之内无法响应屏幕触摸事件或者键盘输入事件就会出现ANR，而BroadcastReceiver如果10秒钟之内还未执行完操作也会出现ANR。

- 为了避免ANR，可以开启子线程执行耗时操作，但是子线程不能更新UI，所以需要子线程与主线程进行通信来解决子线程执行耗时任务后，通知主线程更新UI的场景。。

- 然而，在实际开发中，ANR仍然不可避免的发生了，而且很难从代码上发现，这时候就要用到**ANR日志分析**。**当一个进程发生了ANR之后，系统会在/data/anr目录下创建一个文件traces.txt，通过分析这个文件就能定位出ANR的原因。**

[ANR日志分析指南](https://zhuanlan.zhihu.com/p/50107397)

## 线程优化

### 使用线程池

线程优化的思想就是采用线程池，避免程序中存在大量的Thread。线程池可以重用内部的线程，从而避免了线程的创建和销毁锁带来的性能开销，同时线程池还能有效地控制线程池的最大并法术，避免大量的线程因互相抢占系统资源从而导致阻塞现象的发生。因此在实际开发中，尽量采用线程池，而不是每次都要创建一个Thread对象。

![img](https://upload-images.jianshu.io/upload_images/3985563-7dda79e4c0ec6d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 使用协程







## **其他优化**

**①避免过度的创建对象**

**②不要过度使用枚举，枚举占用的内存空间要比整型大**

**③常量请使用static final来修饰**

**④使用一些Android特有的数据结构，比如SparseArray和Pair等**

**⑤适当采用软引用和弱引用**

**⑥采用内存缓存和磁盘缓存**

**⑦尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄漏。**

## RecyclerView优化

### 刷新



实际项目地址 是我的文件36项目

#### 一般刷新

**更新所有数据**

- 优点：使用简单
- 缺点 ：性能很差 （一次性更新了所有数据 把没有必要的数据也进行了更新）
- **比如有时候我们只想更新一个item 却把所有item都进行了更新 这难道不是性能损耗吗 而且还没有动画效果**
- **更让人难受的就是没有动画就算了 它居然还要闪一下（这太离谱了）**

```java
void notifyDataSetChanged( )
```



#### 局部刷新

- **这样的刷新方式比起全部刷新在性能上面会有很大的提升**

- **并且还伴有动画效果**
- **但是在业务需求很复杂的时候我们使用起来会变得非常复杂**

**更新第 position 个位置上的 item（有动画）**

```java
void notifyItemChanged(int position)
```



**更新从第 positionStart 位置开始的 itemCount 个 item（有动画**

```java
void notifyItemRangeChanged(int positionStart, int itemCount)
```



**在第 position 个位置上插入一个新的 item（有动画）**

> ```java
> void notifyItemInserted(int position)
> ```
>
> 

**将第 fromPosition 个位置上的 item 移动到第 toPosition 个位置上（有动画**

> ```java
> void notifyItemMoved(int fromPosition, int toPosition)
> ```
>
> 

**从第 positionStart 个位置开始插入 itemCount 个新的 item（有动画）**

> ```java
> void notifyItemRangeInserted(int positionStart, int itemCount)
> ```

**删除第 position 个位置上的 item（有动画**）

> ```java
> void notifyItemRemoved(int position)
> ```

**批量删除从第 positionStart 位置开始的 itemCount 个 item（有动画）**

> ```java
> void notifyItemRangeRemoved(int positionStart, int itemCount)
> ```

#### item级别刷新

**在Recyclerview里面有时候只是一个item的某些内容发生了变化 我们却刷新了整个item 虽然性能影响比起整个屏幕小了很多  但这也是一个可以优化的点   **

- **我们直接只修改item里面的内容来达到刷新的目的 就是我个人所理解的item级别刷新**

#### DiffUtil

**掌游的这个 **==BaseRVAdapter<D>==**基类里面就封装了 DiffUtil ** 

这个东西使用的是  **[Myers 差分算法](https://blog.csdn.net/youzi1394046585/article/details/117374061)**

- 上面的那些局部刷新的方式和item内容刷新的方式 我们单独实现的话 业务逻辑可能将会变得非常的复杂  所以这个工具 就是帮我们自动调用那些局部刷新方法的框架

想要深入学习这个算法的可以直接点击链接

**效率如下**

```java
<ul>
*     <li>100 items and 10 modifications: avg: 0.39 ms, median: 0.35 ms
*     <li>100 items and 100 modifications: 3.82 ms, median: 3.75 ms
*     <li>100 items and 100 modifications without moves: 2.09 ms, median: 2.06 ms
*     <li>1000 items and 50 modifications: avg: 4.67 ms, median: 4.59 ms
*     <li>1000 items and 50 modifications without moves: avg: 3.59 ms, median: 3.50 ms
*     <li>1000 items and 200 modifications: 27.07 ms, median: 26.92 ms
*     <li>1000 items and 200 modifications without moves: 13.54 ms, median: 13.36 ms
* </ul>
```

#### 使用



![在这里插入图片描述](https://img-blog.csdnimg.cn/20200903175423668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzU1ODk3NA==,size_16,color_FFFFFF,t_70#pic_center)



**一个普通的JavaBean，但是实现了clone方法，仅用于写Demo模拟刷新用，实际项目不需要，因为刷新时，数据都是从网络拉取的。:**

```java
class TestBean implements Cloneable {
    private String name;
    private String desc;
    ....//get set方法省略
    //仅写DEMO 用 实现克隆方法
    @Override
    public TestBean clone() throws CloneNotSupportedException {
        TestBean bean = null;
        try {
            bean = (TestBean) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return bean;
    }
```



**RecyclerView.Adapter**

```java
ublic class DiffAdapter extends RecyclerView.Adapter<DiffAdapter.DiffVH> {
    private final static String TAG = "zxt";
    private List<TestBean> mDatas;
    private Context mContext;
    private LayoutInflater mInflater;

    public DiffAdapter(Context mContext, List<TestBean> mDatas) {
        this.mContext = mContext;
        this.mDatas = mDatas;
        mInflater = LayoutInflater.from(mContext);
    }

    public void setDatas(List<TestBean> mDatas) {
        this.mDatas = mDatas;
    }

    @Override
    public DiffVH onCreateViewHolder(ViewGroup parent, int viewType) {
        return new DiffVH(mInflater.inflate(R.layout.item_diff, parent, false));
    }

    @Override
    public void onBindViewHolder(final DiffVH holder, final int position) {
        TestBean bean = mDatas.get(position);
        holder.tv1.setText(bean.getName());
        holder.tv2.setText(bean.getDesc());
        holder.iv.setImageResource(bean.getPic());
    }

    @Override
    public int getItemCount() {
        return mDatas != null ? mDatas.size() : 0;
    }

    class DiffVH extends RecyclerView.ViewHolder {
        TextView tv1, tv2;
        ImageView iv;

        public DiffVH(View itemView) {
            super(itemView);
            tv1 = (TextView) itemView.findViewById(R.id.tv1);
            tv2 = (TextView) itemView.findViewById(R.id.tv2);
            iv = (ImageView) itemView.findViewById(R.id.iv);
        }
    }
}
```

**Activity代码：**

```java
public class MainActivity extends AppCompatActivity {
    private List<TestBean> mDatas;
    private RecyclerView mRv;
    private DiffAdapter mAdapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initData();
        mRv = (RecyclerView) findViewById(R.id.rv);
        mRv.setLayoutManager(new LinearLayoutManager(this));
        mAdapter = new DiffAdapter(this, mDatas);
        mRv.setAdapter(mAdapter);
    }

    private void initData() {
        mDatas = new ArrayList<>();
        mDatas.add(new TestBean("张旭童1", "Android", R.drawable.pic1));
        mDatas.add(new TestBean("张旭童2", "Java", R.drawable.pic2));
        mDatas.add(new TestBean("张旭童3", "背锅", R.drawable.pic3));
        mDatas.add(new TestBean("张旭童4", "手撕产品", R.drawable.pic4));
        mDatas.add(new TestBean("张旭童5", "手撕测试", R.drawable.pic5));
    }

    /**
     * 模拟刷新操作
     *
     * @param view
     */
    public void onRefresh(View view) {
        try {
            List<TestBean> newDatas = new ArrayList<>();
            for (TestBean bean : mDatas) {
                newDatas.add(bean.clone());//clone一遍旧数据 ，模拟刷新操作
            }
            newDatas.add(new TestBean("赵子龙", "帅", R.drawable.pic6));//模拟新增数据
            newDatas.get(0).setDesc("Android+");
            newDatas.get(0).setPic(R.drawable.pic7);//模拟修改数据
            TestBean testBean = newDatas.get(1);//模拟数据位移
            newDatas.remove(testBean);
            newDatas.add(testBean);
            //别忘了将新数据给Adapter
            mDatas = newDatas;
            mAdapter.setDatas(mDatas);
            
            
            mAdapter.notifyDataSetChanged();//以前我们大多数情况下只能这样
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }

}
```



**这样的刷新方式不但效率低下而且没有动画效果**



**简单使用DiffUtil，我们需要且仅需要额外编写一个类。**

我们需要实现一个继承自DiffUtil.Callback的类，实现它的四个abstract方法。
虽然这个类叫Callback，但是把它理解成：定义了一些用来比较新老Item是否相等的契约(Contract)、规则(Rule)的类， 更合适。

DiffUtil.Callback抽象类如下：

```java
public abstract static class Callback {
        public abstract int getOldListSize();//老数据集size

        public abstract int getNewListSize();//新数据集size

        public abstract boolean areItemsTheSame(int oldItemPosition, int newItemPosition);//新老数据集在同一个postion的Item是否是一个对象？（可能内容不同，如果这里返回true，会调用下面的方法）

        public abstract boolean areContentsTheSame(int oldItemPosition, int newItemPosition);//这个方法仅仅是上面方法返回ture才会调用，我的理解是只有notifyItemRangeChanged()才会调用，判断item的内容是否有变化

        //该方法在DiffUtil高级用法中用到 ，暂且不提
        @Nullable
        public Object getChangePayload(int oldItemPosition, int newItemPosition) {
            return null;
        }
    }
```

我们来实现一下吧！



```java
/**
 * 介绍：核心类 用来判断 新旧Item是否相等
 */

public class DiffCallBack extends DiffUtil.Callback {
    private List<TestBean> mOldDatas, mNewDatas;//看名字

    /**
      这个构造方法接受两个二参数 一个是老的数据 一个新的数据（也就是网络亲求刚刚拿回来的数据）
     */
    public DiffCallBack(List<TestBean> mOldDatas, List<TestBean> mNewDatas) {
        this.mOldDatas = mOldDatas;
        this.mNewDatas = mNewDatas;
    }

    //老数据集size
    @Override
    public int getOldListSize() {
        return mOldDatas != null ? mOldDatas.size() : 0;
    }

    //新数据集size
    @Override
    public int getNewListSize() {
        return mNewDatas != null ? mNewDatas.size() : 0;
    }

    /**
     * Called by the DiffUtil to decide whether two object represent the same Item.
     * 被DiffUtil调用，用来判断 两个对象是否是相同的Item。
     * For example, if your items have unique ids, this method should check their id equality.
     * 例如，如果你的Item有唯一的id字段，这个方法就 判断id是否相等。
     * 本例判断name字段是否一致
     *
     * @param oldItemPosition The position of the item in the old list
     * @param newItemPosition The position of the item in the new list
     * @return True if the two items represent the same object or false if they are different.
     */
    @Override
    public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) {  //判断对应位置上的新老item是否相同
        return mOldDatas.get(oldItemPosition).getName().equals(mNewDatas.get(newItemPosition).getName());
    }

    /**
     * Called by the DiffUtil when it wants to check whether two items have the same data.
     * 被DiffUtil调用，用来检查 两个item是否含有相同的数据
     * DiffUtil uses this information to detect if the contents of an item has changed.
     * DiffUtil用返回的信息（true false）来检测当前item的内容是否发生了变化
     * DiffUtil uses this method to check equality instead of {@link Object#equals(Object)}
     * DiffUtil 用这个方法替代equals方法去检查是否相等。
     * so that you can change its behavior depending on your UI.
     * 所以你可以根据你的UI去改变它的返回值
     * For example, if you are using DiffUtil with a
     * {@link android.support.v7.widget.RecyclerView.Adapter RecyclerView.Adapter}, you should
     * return whether the items' visual representations are the same.
     * 例如，如果你用RecyclerView.Adapter 配合DiffUtil使用，你需要返回Item的视觉表现是否相同。
     * This method is called only if {@link #areItemsTheSame(int, int)} returns
     * {@code true} for these items.
     
     * 这个方法仅仅在areItemsTheSame()返回true时，才调用。
     
     * @param oldItemPosition The position of the item in the old list
     * @param newItemPosition The position of the item in the new list which replaces the
     *                        oldItem
     * @return True if the contents of the items are the same or false if they are different.
     */
    @Override
    public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) {
        TestBean beanOld = mOldDatas.get(oldItemPosition);
        TestBean beanNew = mNewDatas.get(newItemPosition);
        if (!beanOld.getDesc().equals(beanNew.getDesc())) {
            return false;//如果有内容不同，就返回false
        }
        if (beanOld.getPic() != beanNew.getPic()) {
            return false;//如果有内容不同，就返回false
        }
        return true; //默认两个data内容是相同的
    }
```

然后在**使用**时，注释掉你以前写的notifyDatasetChanged()方法吧，替换成以下代码：

```java
//文艺青年新宠
//利用DiffUtil.calculateDiff()方法，传入一个规则DiffUtil.Callback对象，和是否检测移动item的 boolean变量，得到DiffUtil.DiffResult 的对象

DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallBack(mDatas, newDatas), true);

//利用DiffUtil.DiffResult对象的dispatchUpdatesTo（）方法，传入RecyclerView的Adapter，轻松成为文艺青年

diffResult.dispatchUpdatesTo(mAdapter);

//别忘了将新数据给Adapter
mDatas = newDatas;
mAdapter.setDatas(mDatas);
```

##### 步骤一

在将newDatas 设置给Adapter之前，先调用DiffUtil.calculateDiff()方法，**计算出新老数据集转化的==最小更新集==，就是DiffUtil.DiffResult对象。**
DiffUtil.calculateDiff()方法定义如下：
第一个参数是DiffUtil.Callback对象，
**第二个参数代表是否检测Item的移动，改为false算法效率更高，按需设置.**

```java
public static DiffResult calculateDiff(Callback cb, boolean detectMoves)
```



##### 步骤二

**然后利用DiffUtil.DiffResult对象的dispatchUpdatesTo（）**方法，传入RecyclerView的Adapter，

**替代mAdapter.notifyDataSetChanged()方法。**
查看源码可知，该方法内部，就是根据情况调用了adapter的四大定向刷新方法。

```java
 public void dispatchUpdatesTo(final RecyclerView.Adapter adapter) {
            dispatchUpdatesTo(new ListUpdateCallback() {
                @Override
                public void onInserted(int position, int count) {
                    adapter.notifyItemRangeInserted(position, count);
                }

                @Override
                public void onRemoved(int position, int count) {
                    adapter.notifyItemRangeRemoved(position, count);
                }

                @Override
                public void onMoved(int fromPosition, int toPosition) {
                    adapter.notifyItemMoved(fromPosition, toPosition);
                }

                @Override
                public void onChanged(int position, int count, Object payload) {
                    adapter.notifyItemRangeChanged(position, count, payload);
                }
            });
        }
```

#### 高级用法

**我们也只涉及到两个方法**

一个是

`DiffUtil.Callback`的 

```java
 public Object getChangePayload(int oldItemPosition, int newItemPosition)`
```

**返回的Object就是表示Item改变了哪些内容。**

还有一个就是RecyclerView.Adapter的三个参数的**onBindViewHolder**方法

```java
public void onBindViewHolder(VH holder, int position, List<Object> payloads)
```

**第三个参数就包含了我们在`getChangePayload（）`返回的Object。**

```java
 @Nullable
    @Override
    public Object getChangePayload(int oldItemPosition, int newItemPosition) {
        //实现这个方法 就能成为文艺青年中的文艺青年
        // 定向刷新中的部分更新
        // 效率最高
        //只是没有了ItemChange的白光一闪动画，（反正我也觉得不太重要）
        TestBean oldBean = mOldDatas.get(oldItemPosition);
        TestBean newBean = mNewDatas.get(newItemPosition);

        //这里就不用比较核心字段了,一定相等
        Bundle payload = new Bundle();
        if (!oldBean.getDesc().equals(newBean.getDesc())) {
            payload.putString("KEY_DESC", newBean.getDesc());
        }
        if (oldBean.getPic() != newBean.getPic()) {
            payload.putInt("KEY_PIC", newBean.getPic());
        }

        if (payload.size() == 0)//如果没有变化 就传空
            return null;
        return payload;//
    }
```



简单的说，这个方法返回一个Object类型的**payload**，它包含了某个item的变化了的那些内容。 
 我们这里使用Bundle保存这些变化。

在Adapter里如下重写三参的`onBindViewHolder`：

```java
@Override
    public void onBindViewHolder(DiffVH holder, int position, List<Object> payloads) {
        if (payloads.isEmpty()) {
            onBindViewHolder(holder, position);
        } else {
            //文艺青年中的文青
            Bundle payload = (Bundle) payloads.get(0);
            TestBean bean = mDatas.get(position);
            for (String key : payload.keySet()) {
                switch (key) {
                    case "KEY_DESC":
                        //这里可以用payload里的数据，不过data也是新的 也可以用
                        holder.tv2.setText(bean.getDesc());
                        break;
                    case "KEY_PIC":
                        holder.iv.setImageResource(payload.getInt(key));
                        break;
                    default:
                        break;
                }
            }
        }
    }
```



#### 再优化-AsyncListDiffer

前面我和大家分享了**屏幕的刷新机制   16.6ms一次**



DiffUtil内部采用的Eugene W. Myers’s difference 算法，**但该算法不能检测移动的item，所以Google在其基础上改进支持检测移动项目，但是检测移动项目，会更耗性能。**
在有1000项数据，200处改动时，这个算法的耗时：
打开了移动检测时：平均值：27.07ms，中位数：==26.92ms==。
关闭了移动检测时：平均值：13.54ms，中位数：==13.36ms==。
有兴趣可以自行去源码头部阅读注释，对我们比较有用的是其中一段提到，
如果我们的list过大，这个计算出DiffResult的时间还是蛮久的，所以我们应该将获取DiffResult的过程放到子线程中，并在主线程中更新RecyclerView。 

**切线程南 大家可以自行实现  **

但是南  也可以去使用==AsyncListDiffer==

在这里我就不多说啦  也很简单  给大家放个博客吧  

[AsyncListDiffer](https://www.jianshu.com/p/7799c9e9bd02)

### 缓存机制

**要说Recyclerview的优化 就必须谈谈 RecyclerView的缓存机制**

==先去总览recycler这个内部类==

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019051015301074.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200903175206365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzU1ODk3NA==,size_16,color_FFFFFF,t_70#pic_center)







![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031145314548.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6cTIwMDY=,size_16,color_FFFFFF,t_70#pic_center)

#### scrap一级缓存

- scrap 分为两个集合：
- **mAttachedScrap 和**
- **mChangedScrap**



##### 准备一





为了能够更好的理解下面的内容，这里先介绍一下 ==pre-layout==与 ==post-layout== 是什么。

有这样的一个场景：我们有3个item【a, b, c】，其中a与b显示在屏幕上，当我们删除b的时候，c会显示出来。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153044152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)



我们希望看到的是 c 从底部顺利滑动到它的新位置。

但这是如何发生呢？

我们知道新布局中 c 的最终位置，但我们如何知道它应该从何处开始滑动？

**谷歌的解决方案提供如下：**

在adapter发生更改后，**RecyclerView会从LayoutManager请求两个布局。**



- 第一个 ——**pre-layout**，因为我们可以收到适配器的变化，所以这里我们可以做一些特殊的处理。在我们的例子中，因为我们现在知道b被删除了，所以我们会额外的显示出c，尽管它已经超出界限。

- 第二个 ——**post-layout**，一个正常的布局，对应于更改后的适配器状态。



![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153102320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)

现在，通过比较pre-layout和post-layout中c的位置，我们可以正确地为其设置动画。



==This kind of animation — when the animated view is not present either in previous layout or in the new one — is called predictive animation。==  



- 关于这种动画哈==我个人猜测一下==（只是我自己的猜测哈）
- 就像是那种==过度元素动画==效果 因为它是根据前后位置自动生成的动画嘛  过度元素动画好像也是这个样子（这里仅仅是我的个人理解 不一定对哈  但我觉得好像挺对的）



##### 准备二

**Detach和Remove**

- **detach**: 在ViewGroup中的实现很简单，只是将ChildView从ParentView的ChildView数组中移除，ChildView的mParent设置为null, 可以理解为轻量级的临时remove, **因为View此时和View树还是藕断丝连, 这个函数被经常用来改变ChildView在ChildView数组中的次序**。View被detach一般是**临时的**，在后面会被重新attach。
-  **remove**: 真正的移除，不光被从ChildView**数组中除名**，其他和View树各项联系也会被**彻底斩断**(不考虑Animation/LayoutTransition这种特殊情况)， 比如焦点被清除，从TouchTarget中被移除等。



##### 作用

- ==scrap 仅仅在 layout 期间不为空==。当 LayoutManager 开始 layout 的时候（pre-layout 或  post-layout），**会将所有的 viewHolder 都放到 scrap 中。然后一个个在取回来**，除非有些 view 发生了变化。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153147931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)



为啥要先放到 scrap 了之后，再取出来啊，这难道不是吃饱了撑的吗？

- 答 ：==是减少 layout 方法调用带来的性能影响。==

**第一**

首先我们要了解，**任何一个ViewGroup都会至少经历两次onLayout的过程**，对应的childView就会**经历detach**和**attach**的过程，而在这个过程中，ScrapViews就起了缓存的作用，这样就**不需要重复创建childView和bind**。

 **所以ScrapView主要用于对于屏幕内的ChildView的缓存，缓存中的ViewHolder不需要重新Bind，缓存时机是在onLayout的过程中，并且用完即清空**

*[View为什么会至少进行2次onMeasure、onLayout的南？ 我在这里给大家找了一篇比较好的博客  大家自己看看就好啦](https://www.jianshu.com/p/733c7e9fb284)*

**第二**

**比如说，当我们调用 notifyItemRangeChanged 方法的时候，会触发 requestLayout 方法，就会重新布局，重新布局的话，就会先将 viewHolder 放到 scrap 中**

==（屏幕上变化的放入mChangedScrap 中，其余的放入mAttachedScrap 中）==

，**然后 fill（） 布局的时候，再从 mAttachedScrap 里面取出来直接使用。mChangedScrap 中的 viewHolder 会被移动到 RecycledViewPool 中，所以 mChangedScrap 对应的 item 需要从 pool（也就是第四级缓存） 中取对应的 viewHolder，然后重新绑定。**

看一下这个图 我们一下子就明白啦！

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153221516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)



##### 结束

**现在再来思考一下，为什么需要 mChangedScrap 与 mAttachedScrap 这两个缓存 来作为一级缓存？**



答：**因为 mChangedScrap 表示 item 变化了，有可能是数据变化，有可能是类型变化，所以它的 viewHolder 无法重用，只能去 RecycledViewPool 中重新取对应的，然后再重新绑定。**



- 注意： **mChangedScrap 只能在 pre-layout 中使用，mAttachedScrap 可以在 pre-layout 与 post-layout 中使用。**







#### CacheViews二级缓存

**最大数默认为2**

我个人理解的是个在屏幕上==快速来回滑动时==的缓存优化策略

**CacheViews其实就是和我们平常使用过程中息息相关的一个缓存。CacheViews缓存的特点是CacheViews内的缓存在复用的时候不需要调用bind，也就是在滑动的过程中，免去了bind的过程，提高滑动的效率。**



它是一个 ArrayList 类型，不区分 viewHolder 的类型，大小限制为**2**，但是你可以使用 `setItemViewCacheSize()`这个方法调整它的大小。

由于它不区分 viewHolder 的类型，所以只能根据 position 来获取 viewHolder 。

```java
/ /Search in our first-level recycled view cache.
           final int cacheSize = mCachedViews.size();
           for (int i = 0; i < cacheSize; i++) {
               final ViewHolder holder = mCachedViews.get(i);
               // invalid view holders may be in cache if adapter has stable ids as they can be
               // retrieved via getScrapOrCachedViewForId
               if (!holder.isInvalid() && holder.getLayoutPosition() == position) {
                   if (!dryRun) {
                       mCachedViews.remove(i);
                   }
                   if (DEBUG) {
                       Log.d(TAG, "getScrapOrHiddenOrCachedHolderForPosition(" + position
                               + ") found match in cache: " + holder);
                   }
                   return holder;
               }
           }
```



首先我们通过源码可以知道CacheViews是一个ArrayList，可以看到获取的时候是遍历CacheViews，当缓存的ViewHolder和所需要的position相同的并且有效才可以复用。
 和上面分析的一样，可以知道这个缓存的ViewHolder是有效的才可以复用，所以在判断是否需要bind的时候，就不需要重新bind了。



#### Extension三级缓存



这个玩意是我们用户自己来实现的缓存  但是我们一般情况下并没有实现这个缓存机制   如果特殊情况需要的  我们可以根据当时的业务情况 判断是否实现。



#### Pool四级缓存

> - 最大数量为==5==，可以通过 ==setMaxRecycledViews()== 方法来设置每个类型储存的容量。
>
> - 还有一个==重要==的点就是，可以多个列表==公用==一个 RecycledViewPool，使用 setRecycledViewPool() 方法。

```java
public static class RecycledViewPool {
    private static final int DEFAULT_MAX_SCRAP = 5;
    static class ScrapData {
        ArrayList<ViewHolder> mScrapHeap = new ArrayList<>();
        int mMaxScrap = DEFAULT_MAX_SCRAP;
        long mCreateRunningAverageNs = 0;
        long mBindRunningAverageNs = 0;
    }
    SparseArray<ScrapData> mScrap = new SparseArray<>();
    }
```

可以看到RecyclerPool内部其实是一个**SparseArray**（我记得当时好像是郭祥瑞哥哥在群里总结缓存的时候提到过这个哦），可想而知，key就是我们的ViewType，而Value是ArrayList<ViewHolder>。

我们来看一下RecyclerPool的put方法。

```java
public void putRecycledView(ViewHolder scrap) {
        final int viewType = scrap.getItemViewType();
        final ArrayList<ViewHolder> scrapHeap = getScrapDataForType(viewType).mScrapHeap;
        if (mScrap.get(viewType).mMaxScrap <= scrapHeap.size()) {
            return;
        }
        if (DEBUG && scrapHeap.contains(scrap)) {
            throw new IllegalArgumentException("this scrap item already exists");
        }
        //重置ViewHolder
        scrap.resetInternal();
        scrapHeap.add(scrap);
    }
```

其中**resetInternal**方法值得我们注意。

```java
void resetInternal() {
        mFlags = 0;
        mPosition = NO_POSITION;
        mOldPosition = NO_POSITION;
        mItemId = NO_ID;
        mPreLayoutPosition = NO_POSITION;
        mIsRecyclableCount = 0;
        mShadowedHolder = null;
        mShadowingHolder = null;
        clearPayload();
        mWasImportantForAccessibilityBeforeHidden = ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO;
        mPendingAccessibilityState = PENDING_ACCESSIBILITY_STATE_NOT_SET;
        clearNestedRecyclerViewIfNotNested(this);
    }
```

可以看到所有被put进入RecyclerPool中的ViewHolder都会被重置，这也就意味着RecyclerPool中的ViewHolder再被复用的时候是需要重新Bind的。这一点就可以区分和CacheViews中缓存的区别。

#### 总结

![img](https://upload-images.jianshu.io/upload_images/7866586-921306270df56c0f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/703/format/webp)

- 现在，我们来思考下一个问题**：mCachedViews 的大小是有限制的，如果存不下了，怎么办？**

实际上，mCachedViews 虽然是一个 ArrayList ，但是它的**工作方式却和链表有点类似**。当 mCachedViews 满了之后，它会将最先存入的元素移除，放入到 pool 中，如下图



​        		                                   **我们先来看看cache（第二级缓存）和pool（第四级缓存）的关系**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153258761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)

当我们滑动列表的时候，一旦 item 超出了屏幕，那么就会被放入到 mCachedViews 中，如果满了，就会将“尾部”的元素移动到 pool 中，如果 pool 也满了，那么就会被丢弃，等待回收。

下面，用几个场景来深入理解一下我刚才分享的四级缓存知识：

**场景一：**



**我们假设一个屏幕只能展示两个item**   **再假设345现在是没有颜色的**     **最开始的时候3和4被展示再屏幕上**  **然后我们来看看这第一个情况是怎么产生的**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153310821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)

- 先看图的左边（此时假设 cache 与 pool 中没有东西），**当向上滑动时**，3 最先进入 mCachedViews，随后是 4 与 5，5 会将3挤出来，3就会跑到 pool 中去了。

- 再看图的右边，继续向上滑动时，4 被 6 挤出来，放到了 pool 中，**同时**，8需要显示，那么就会先从 pool 中取，发现正好有一个 3，那么就会取出来，将 3 重新显示到屏幕上。

**场景二：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153319785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)

**如果，向上滑倒7显示出来之后，不再继续向上，而是往下滑动，那么又会怎么样呢？**

看图的右边，很明显，5 从 cache 中被取出来直接复用，不用重新绑定，7 被放入了 cache 中。

**思考一下，对于这种情况，我们应该如何加以利用呢？**

**比如，我们有一个壁纸库的列表，用户经常会上下（左右）滑动，那么我们增加 cache 的容量，就会获得更好得性能。然而对于feed流之类得列表，用户很少返回，所以增加 cache 容量意义不大。**

再深入一下，我们继续向上滑动，那么，4 与 7 会放入到 cache 中，3 会从 pool 中取出来，但是，这里需要注意，因为 3 是从 pool 中取出来的，所以它需要重新绑定，但是从逻辑上来说，如果 3 位置的数据没有发生变化，它不需要重新绑定，也是有效的。所以，你也可以把这里当作一个优化点，在 onBindViewHolder() 方法中，检查一下。

再再深入一下，在我们滑动的过程中，一个类型的 viewHolder 在 pool 中应该一直只会存在一个（除非你使用了 GridLayoutManager），所以，如果你的 pool 中存在多个 viewHolder 的话，他们在滚动过程中基本上是无用的。

**场景三：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153337841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)

当我们调用 **notifyDataSetChanged()** 或者 notifyItemRangeChanged(i, c) （c这个范围非常大的时候），那么很多 viewHolder 都会最终被放入到 pool 中，因为 pool 只能放置 5 个，那么多余的就会被丢弃，等待回收。==最重要的是会重新 create 与 bind 对性能影响比较大==。**还可能会直接引起gc的发生**   如果你的列表能够容纳很多行，而且使用 notifyDataSetChanged 方法比较频繁，那么你应该考虑设置一下容量大小



 **Stable Ids**

**这个东西纯属我在别人博客里面看到的 并没有使用过  同样也是第一次见到  在这里只做一个单纯的分享  具体的使用  还有待研究**

当调用 notifyDataSetChanged 的时候，recyclerView 不知道到底发生了什么，所以它只能认为所有的东西都发生了变化，即，将所有的 viewHolder 都放入到 pool 中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153407946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)

但是，如果我们设置了 stable ids，那么就会不一样了：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190510153426276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEzMDcyNA==,size_16,color_FFFFFF,t_70)

viewHolder 被放入了 scrap 中，而不是 pool 中。注意，这里，它的性能提升了很多！

1. 不用重新绑定，重新创建新的 viewHolder，不用重新 addView。addView会导致重新测量…
2. 原来我们需要调用 notifyItemMoved(4, 6)，但是现在直接调用 notifyDataSetChanged() 就好了

### RV性能优化

在前面我们已经或多或少的见到了一些关于Rv缓存方面的优化

也就是改变**第二级缓存和第四级缓存的默认大小 来在某些场景达到性能优化的效果**

到现在我们已经了解到了RV的四级缓存策略  那么就让我们来学习一些它的性能优化的策略吧！！

####  **一.不要在onBind的时候设置onClickListener**

当为RecyclerView中的ItemView中的设置点击事件或者其他事件的时候，往往我们的写法总是在onBindViewHolder中给ItemView去设置点击事件。

**说实话在我刚学会Recyclerview的时候 我最喜欢这样写了  越写越爽**

```java
@Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        holder.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //do something
            }
        });
    }
```

**问题**

这时候我们可以考虑一下我们这种写法是否合理，从前面的源码分析甚至对RecyclerView有一定基础了解的都知道`onBindViewHolder`的调用时机是View滑到页面可显示位置时，就会出发这个方法回调。那当我们这样设置的时候就意味着，这个View只要滑到屏幕内，

- 这个我们就会给这个itemView设置一次onClickListener,
- 并且这个onClickListener每次滑动的时候都是重新new出来的。～

显而易见这样是不合理的。好吧，那我们优化一下

**第一次优化**

```java
@Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        holder.setOnClickListener(mOnClickListener);
    }
    
    private View.OnClickListener mOnClickListener = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            //do something
        }
    }
```

**优化：** 嗯，这样看起来舒服多了，**这样我们每次onBindViewHolder的时候设置的onClickListener都是同一个mOnClickListener,这样我们就不用每次在onBindViewHolder都new一个onClickListener了**。

**问题：**
 但是这样真 就够了吗？再回想一下，RecyclerView的优势就是对于ViewHolder的复用。这样考虑一下，当`position =1`的第一次显示在界面显示，我们已经对view设置过onClickListener，我们这是滑出`position=1`，再滑回`position=1`。当我们向下滑这时`position=1`被放入缓存，如果仅仅是在CacheViews缓存中还好，因为不会调onBindViewHolder方法（具体原因见前面讲解）,如果是在CacheViews或者RecyclerPool的时候，每次滑入还会调onBindViewHolder方法，也就是说，**明明我们已经给这个View设置过onClickListener了，每次显示的时候，我们还要再给这个view设置一次onClickListener**，这样肯定是不合理的。那就再优化一下～

**第二次优化**

```java
private class XXXHolder extends RecyclerView.ViewHolder {
        private EditText mEt;
        EditHolder(View itemView) {
            super(itemView);
            mEt = (EditText) itemView;
            mEt.setOnClickListener(mOnClickListener);
        }
    }
    private View.OnClickListener mOnClickListener = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            //do something
        }
    }
```

没错，就是上面这样，既然每次Bind的时候没必要重复设置onClickListener,那么我们就在`onCreateViewHolder`中设置，在这个ViewHolder在new的时候，设置一个全局的OnClickListener。这样刚才考虑的问题就迎刃而解了。

#### **二.不要在onBindViewHolder做逻辑判断和计算。**

这也是我们经常容易犯的问题，原因其实和第一条也是相似的，**每次滑入后我们都必须做完这些逻辑判断和计算，页面才能绘制出来**，这样明显是很消耗性能的。常见的一些逻辑判断：

- TextView.setText(Html.fromHtml(str);
- 计算UI的宽高比，margin，padding，每次都用DensityUtils.dp2px()转换。
   3.每次都new一些可以复用都对象:adapter,viewparam
   等。。。

**优化建议：**

- 1.可以考虑尽可能都逻辑前移
- 2.onBindViewHolderz中都对象考虑懒加载或者变成私有变量。

#### **三.RecyclerView嵌套RecyclerView考虑设置RecyclerPool缓存。**

这个是我们经常考虑不到都一点，我们经常有这样都需求，一个竖向都RecyclerView需要展示多个横向滑动都RecyclerView都楼层。这时候我们就可以考虑使用RecyclerPool给子RecyclerView设置一个缓存池，这样当存在多个横向滑动的RecyclerView时，就可以减少子RecyclerView的子ViewHolder的创建，实现多个RecyclerView之间的复用。。

```java
private RecyclerView.RecycledViewPool childPool;
public XXAdapter(){
    childPool = new RecyclerView.RecycledViewPool();
}
private class RcyViewHolder extends RecyclerView.ViewHolder {
        private SRecyclerView sRcy;

        public RcyViewHolder(View itemView) {
            super(itemView);
            sRcy = itemView.findViewById(R.id.rcy_child);
            LinearLayoutManager manager = new LinearLayoutManager(mContext);
            //1.设置回收
            manager.setRecycleChildrenOnDetach(true);
            manager.setOrientation(LinearLayoutManager.HORIZONTAL);
            sRcy.setLayoutManager(manager);
            //2.设置缓存Pool
            sRcy.setRecycledViewPool(childPool);
        }
    }
```

#### 四.对于大量图片的RecyclerView考虑重写onScroll事件，滑动暂停后再加载

这个我们平时就经常实现了，当长图片列表的时候，我们经常做这样的优化，防止图片的大量加载，毕竟图片一直是内存占用大户。

#### 五.对于复杂布局的RecyclerView考虑重写onScroll事件，滑动暂停后再加载复杂布局

这个其实我们平时没有考虑，考虑一种情况：RecyclerView中存在几种绘制复杂，占用内存高的楼层类型，但是用户只是快速滑动到底部，并没有必要绘制计算这几种复杂类型，所以也可以考虑对滑动速度，滑动状态进行判断，满足条件后再加载这几种复杂的。

#### 六.不要什么都用notifydatasetchange!!!!

这个其实前面算是具体说了

这里我就不再赘述啦！

#### 七.减少每个ItemView的层级嵌套

这个前面也相当于说了  只是这个是在Recycerview中而已   

都一样的嘛

#### 八.使用recyclerview prefetch功能

 [RecyclerView 数据预取](https://yq.aliyun.com/articles/226475)

1. 使用prefetch以后，recyclerView的流畅度对页面复杂度的敏感性降低。
2. 在高复杂度（recyclerView的子项view的创建和绑定更加耗时）情况下，prefetch功能确实能显著提高页面流畅度。

#### 九.设置setItemViewCacheSize缓存大小

```java
recyclerView.setItemViewCacheSize(20);
 recyclerView.setDrawingCacheEnabled(true);
 recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);
```

1.CacheViews中的缓存只能position相同才能复用，并且不会重新Bind.
       2**.CacheViews满了后会移除到RecyclerPool中，并重置ViewHolder.**
       3.**RecyclerPool中的缓存复用需要重新Bind.**



所以我们可以适当的通过调用setItemViewCacheSize方法，来增加CacheViews的大小（默认是2），来防止小范围的滑动导致的重复Bind而导致的卡顿。**典型的拿空间还时间，所以要考虑内存问题，根据自己的应用实际情况设置大小**

#### 十.如果RecyclerView固定宽高，只是用于展示固定大小的组件，然后设置`recyclerView.setHasFixedSize(true)`这样可以避免每次绘制Item时，不再重新计算Item高度。

==就是说每一个item的大小都是一样的时候  就没必要每次都去计算它的大小了==

#### 十一.使用getExtraLayoutSpace为LayoutManager设置更多的预留空间

http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0209/2452.html

**在RecyclerView的元素比较高，一屏只能显示一个元素的时候，第一次滑动到第二个元素会卡顿。**  

RecyclerView (以及其他基于adapter的view，比如ListView、GridView等)使用了**缓存机制重用子 view**（即系**统只将屏幕可见范围之内的元素保存在内存中**，在滚动的时候不断的重用这些内存中已经存在的view，而不是新建view）。

这个机制会导致一个问题，启动应用之后，**在屏幕可见范围内，如果只有一张卡片可见，当滚动的时 候，RecyclerView找不到可以重用的view了，它将创建一个新的，因此在滑动到第二个feed的时候就会有一定的延时，但是第二个feed之 后的滚动是流畅的，因为这个时候RecyclerView已经有能重用的view了。**

如何解决这个问题呢，其实只需重写getExtraLayoutSpace()方法。根据官方文档的描述 getExtraLayoutSpace将返回LayoutManager应该预留的额外空间（显示范围之外，应该额外缓存的空间）。







### 问题

-----------------------------------------------由于RecyclerView缓存view复用导致图片错乱

Recyclerview的缓存机制，我们主要在对RecyclerView的ItemView某些图片进行了属性动画变换，这样就改变了ViewHolder中ImageView的属性，在滑动时，==RecyclerView的缓存复用机制可能导致ViewHolder不会重新创建，也不会重新bindView==（图片错位的主要原因），这样某些ItemView的图片是View属性动画变换后的图片，导致不是自己想要的结果。

关于这个问题我也是放一篇博客吧！

[图片错乱](https://blog.csdn.net/feelinghappy/article/details/80604566)

## 工具



### Lint（代码风险检查工具）

https://blog.csdn.net/zxm528/article/details/70766253

一些Lint规则如下：
　　1、使用组合控件： 包含了一个ImageView以及一个TextView控件的LinearLayout如果能够作为一个组合控件将会被更有效的处理。
　　2、合并作为根节点的帧布局(Framelayout) ：如果一个帧布局时布局文件中的根节点，而且它没有背景图片或者padding等，更有效的方式是使用merge标签替换该Framelayout标签 。                              
　　3、无用的叶子节点：通常来说如果一个布局控件没有子视图或者背景图片，那么该布局控件时可以被移除(由于它处于 invisible状态)。
　　4、无用的父节点 ：如果一个父视图即有子视图，但没有兄弟视图节点，该视图不是ScrollView控件或者根节点，并且它没有背景图片，也是可以被移除的，移除之后，该父视图的所有子视图都直接迁移至之前父视图的布局层次。同样能够使解析布局以及布局层次更有效。
　　5、过深的布局层次：内嵌过多的布局总是低效率地。考虑使用一些扁平的布局控件，例如 RelativeLayout、GridLayout ，来改善布局过程。默认最大的布局深度为10 。

### 开发者选项



 使用 GPU 渲染模式分析工具进行分析（大家这个看看官方的 就好了）

https://developer.android.google.cn/topic/performance/rendering/profile-gpu

